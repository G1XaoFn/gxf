#TMSH-VERSION: 14.1.0.6

apm oauth db-instance /Common/oauthdb {
    description "Default OAuth DB."
}
apm report default-report {
    report-name sessionReports/sessionSummary
    user /Common/admin
}
ilx global-settings {
    debug-port-blacklist { 47019 54321 60000 }
}
#a new data table begin:
ltm default-node-monitor {
    rule /Common/icmp
}
#a new data table begin:
ltm nat /Common/nat1 {
    inherited-traffic-group true
    originating-address 3.3.3.3
    traffic-group /Common/traffic-group-1
    translation-address 2.2.2.2
}
#a new data table begin:
ltm node /Common/21.86.57.104 {
    address 21.86.57.104
    description 111111
}
#a new data table begin:
ltm node /Common/21.86.57.105 {
    address 21.86.57.105
}
#a new data table begin:
ltm node /Common/server1 {
    address 172.16.20.1
}
#a new data table begin:
ltm node /Common/server2 {
    address 172.16.20.2
}
#a new data table begin:
ltm pool /Common/Pool_ABC_12_80 {
    description "pool description"
    load-balancing-mode least-connections-member
    members {
        /Common/21.86.57.104:8081 {
            address 21.86.57.104
            description 3333333
        }
        /Common/21.86.57.105:8081 {
            address 21.86.57.105
        }
    }
    monitor /Common/tcp
}
#a new data table begin:
ltm pool /Common/pool_web {
    members {
        /Common/server1:80 {
            address 172.16.20.1
            session user-disabled
            state user-down
        }
        /Common/server2:80 {
            address 172.16.20.2
            session user-disabled
        }
    }
    monitor /Common/tcp
}
#a new data table begin:
ltm rule /Common/iRules-MCC-MMR-VS-116-80 {
when HTTP_REQUEST {
    if { [HTTP::uri] starts_with "/tproxy1"} {
        pool MCC-MMR-POOL-116-80-1
        #log local5.debug "80-luri:[HTTP::uri]"
    }
    elseif { [HTTP::uri] starts_with "/tproxy2"} {
        pool MCC-MMR-POOL-116-80-2
        #log local5.debug "80-2uri:[HTTP::uri]"
    }
    else {
        #log local5.debug "otheruri:[HTTP::uri]"
    }
}
}
#a new data table begin:
ltm snat-translation /Common/21.86.79.173 {
    address 21.86.79.173
    inherited-traffic-group true
    traffic-group /Common/traffic-group-1
}
#a new data table begin:
ltm snat-translation /Common/21.86.79.174 {
    address 21.86.79.174
    inherited-traffic-group true
    traffic-group /Common/traffic-group-1
}
#a new data table begin:
ltm snatpool /Common/Snatpool_21.86.79.173 {
    members {
        /Common/21.86.79.173
        /Common/21.86.79.174
    }
}
#a new data table begin:
ltm virtual /Common/VS_ABC_159_8081 {
    creation-time 2019-12-14:13:59:18
    destination /Common/21.86.79.159:8081
    ip-protocol tcp
    last-modified-time 2019-12-15:17:01:14
    mask 255.255.255.255
    persist {
        /Common/source_addr {
            default yes
        }
    }
    pool /Common/Pool_ABC_12_80
    profiles {
        /Common/tcp { }
    }
    source 0.0.0.0/0
    source-address-translation {
        pool /Common/Snatpool_21.86.79.173
        type snat
    }
    translate-address enabled
    translate-port enabled
}
#a new data table begin:
ltm virtual /Common/vs_webserver {
    auth {
        /Common/ssl_ocsp
    }
    clone-pools {
        /Common/pool_web {
            context clientside
        }
        /Common/pool_web {
            context serverside
        }
    }
    creation-time 2019-12-16:02:20:14
    description cccc
    destination /Common/10.1.100.1:80
    flow-eviction-policy /Common/default-eviction-policy
    ip-protocol tcp
    last-hop-pool /Common/pool_web
    last-modified-time 2019-12-15:11:57:41
    mask 255.255.255.255
    pool /Common/pool_web
    profiles {
        /Common/apm-enduser-if-cache { }
        /Common/bbbbb { }
        /Common/clientssl {
            context clientside
        }
        /Common/http-proxy-connect { }
        /Common/httpcompression { }
        /Common/isession {
            context serverside
        }
        /Common/request-log { }
        /Common/serverssl {
            context serverside
        }
        /Common/service { }
        /Common/stats { }
        /Common/stream { }
        /Common/tcp { }
        /Common/websocket { }
        /Common/xml { }
    }
    service-down-immediate-action reset
    source 0.0.0.0/0
    source-address-translation {
        pool /Common/Snatpool_21.86.79.173
        type snat
    }
    translate-address enabled
    translate-port enabled
}
#a new data table begin:
ltm virtual-address /Common/10.1.100.1 {
    address 10.1.100.1
    arp enabled
    mask 255.255.255.255
    traffic-group /Common/traffic-group-1
}
#a new data table begin:
ltm virtual-address /Common/21.86.79.159 {
    address 21.86.79.159
    arp enabled
    mask 255.255.255.255
    traffic-group /Common/traffic-group-1
}
#a new data table begin:
ltm monitor tcp /Common/aaa {
    adaptive disabled
    defaults-from /Common/tcp
    destination 1.1.1.1:80
    interval 5
    ip-dscp 0
    recv 123
    recv-disable none
    reverse enabled
    send none
    time-until-up 0
    timeout 16
    transparent enabled
}
#a new data table begin:
ltm monitor tcp /Common/bbbb {
    adaptive disabled
    defaults-from /Common/tcp
    destination *:*
    interval 5
    ip-dscp 0
    recv none
    recv-disable none
    send none
    time-until-up 0
    timeout 16
}
#a new data table begin:
ltm monitor tcp /Common/tcp-MCC-MMA-21 {
    adaptive disabled
    defaults-from /Common/tcp
    destination 10.10.10.10:*
    interval 5
    ip-dscp 0
    recv none
    recv-disable none
    send none
    time-until-up 0
    timeout 16
}
#a new data table begin:
ltm persistence source-addr /Common/source_addr-MCC-MMA-112 {
    app-service none
    defaults-from /Common/source_addr
    timeout 1200
}
#a new data table begin:
ltm profile http /Common/bbbbb {
    app-service none
    defaults-from /Common/http
    proxy-type reverse
}
#a new data table begin:
net route /Common/21.86.57.216 {
    description "route 21.86.57.216"
    gw 21.86.117.1
    network 21.86.57.216/32
}
#a new data table begin:
net ipsec ike-daemon /Common/ikedaemon {
    log-publisher /Common/default-ipsec-log-publisher
}
pem global-settings analytics { }
pem global-settings gx { }
pem global-settings policy { }
security bot-defense profile /Common/bot-defense {
    app-service none
    whitelist {
        apple_touch_1 {
            match-order 2
            url /apple-touch-icon*.png
        }
        favicon_1 {
            match-order 1
            url /favicon.ico
        }
    }
}
security bot-defense profile /Common/bot-defense-device-id-generate-after-access {
    api-access-strict-mitigation disabled
    app-service none
    class-overrides {
        "/Common/Malicious Bot" { }
        "/Common/Mobile Application" { }
        "/Common/Suspicious Browser" { }
        "/Common/Trusted Bot" {
            mitigation {
                action alarm
            }
        }
        "/Common/Untrusted Bot" { }
        /Common/Browser { }
        /Common/Unknown { }
    }
    deviceid-mode generate-after-access
    dos-attack-strict-mitigation disabled
    perform-challenge-in-transparent enabled
    whitelist {
        apple_touch_1 {
            match-order 2
            url /apple-touch-icon*.png
        }
        favicon_1 {
            match-order 1
            url /favicon.ico
        }
    }
}
security bot-defense profile /Common/bot-defense-device-id-generate-before-access {
    api-access-strict-mitigation disabled
    app-service none
    class-overrides {
        "/Common/Malicious Bot" { }
        "/Common/Mobile Application" { }
        "/Common/Suspicious Browser" { }
        "/Common/Trusted Bot" {
            mitigation {
                action alarm
            }
        }
        "/Common/Untrusted Bot" { }
        /Common/Browser { }
        /Common/Unknown { }
    }
    deviceid-mode generate-before-access
    dos-attack-strict-mitigation disabled
    perform-challenge-in-transparent enabled
    whitelist {
        apple_touch_1 {
            match-order 2
            url /apple-touch-icon*.png
        }
        favicon_1 {
            match-order 1
            url /favicon.ico
        }
    }
}
security bot-defense profile /Common/bot-defense-device-id-none {
    api-access-strict-mitigation disabled
    app-service none
    class-overrides {
        "/Common/Malicious Bot" { }
        "/Common/Mobile Application" { }
        "/Common/Suspicious Browser" { }
        "/Common/Trusted Bot" {
            mitigation {
                action alarm
            }
        }
        "/Common/Untrusted Bot" { }
        /Common/Browser { }
        /Common/Unknown { }
    }
    deviceid-mode none
    dos-attack-strict-mitigation disabled
    perform-challenge-in-transparent disabled
    whitelist {
        apple_touch_1 {
            match-order 2
            url /apple-touch-icon*.png
        }
        favicon_1 {
            match-order 1
            url /favicon.ico
        }
    }
}
security dos ipv6-ext-hdr /Common/dos-ipv6-ext-hdr {
    frame-types { auth dstopt esp frag hbh mobility route }
}
security dos udp-portlist /Common/dos-udp-portlist {
    list-type exclude-listed-ports
}
security firewall config-change-log {
    log-publisher /Common/local-db-publisher
}
security scrubber profile /Common/scrubber-profile-default {
    advertisement-ttl 300
}
#a new data table begin:
sys compatibility-level {
    level 0
}
#a new data table begin:
sys management-ovsdb {
    bfd-disabled
    bfd-route-domain none
    ca-cert-file none
    cert-file none
    cert-key-file none
    disabled
    flooding-type replicator
    log-level info
    logical-routing-type none
    tunnel-maintenance-mode active
}
#a new data table begin:
sys diags ihealth {
    expiration 30
    options none
    password none
    user none
}
#a new data table begin:
sys ecm cloud-provider /Common/aws-ec2 {
    description "The aws-ec2 parameters"
    property-template {
        account { }
        availability-zone {
            valid-values { a b c d }
        }
        instance-type {
            valid-values { t2.micro t2.small t2.medium m3.medium m3.large m3.xlarge m3.2xlarge c3.large c3.xlarge c3.2xlarge c3.4xlarge c3.8xlarge r3.large r3.xlarge r3.2xlarge r3.4xlarge r3.8xlarge }
        }
        region {
            valid-values { us-east-1 us-west-1 us-west-2 sa-east-1 eu-west-1 eu-central-1 ap-southeast-2 ap-southeast-1 ap-northeast-1 }
        }
    }
}
#a new data table begin:
sys ecm cloud-provider /Common/dnet {
    description "The dnet parameters"
}
#a new data table begin:
sys ecm cloud-provider /Common/vsphere {
    description "The vsphere parameters"
    property-template {
        cloud-host-ip { }
        dhcp-network-name { }
        end-point-url { }
        node-name { }
    }
}
#a new data table begin:
sys file ssl-key /Common/f5_api_com.key {
    cache-path /config/filestore/files_d/Common_d/certificate_key_d/:Common:f5_api_com.key_110460_1
    passphrase $M$k8$tYjyP+1caO4ncumyiBfu49hRIqpyQXTREqfFxiUABt2TX251wrBiKKZx9cMYriV7mU+XN1yXBbL2uY03/rsoso9OMnkvd8tkYs0Jtv+AeIM=
    revision 1
    source-path file:///config/ssl/ssl.key/f5_api_com.key
}
#a new data table begin:
sys software update {
    auto-check enabled
    auto-phonehome enabled
    frequency weekly
}
#a new data table begin:
wom endpoint-discovery { }
#TMSH-VERSION: 14.1.0.6

#a new data table begin:
cm cert /Common/dtca-bundle.crt {
    cache-path /config/filestore/files_d/Common_d/trust_certificate_d/:Common:dtca-bundle.crt_61191_1
    checksum SHA1:1289:235a0463916c6013754549a651a61e07aaec320f
    revision 1
}
#a new data table begin:
cm cert /Common/dtca.crt {
    cache-path /config/filestore/files_d/Common_d/trust_certificate_d/:Common:dtca.crt_61187_1
    checksum SHA1:1289:235a0463916c6013754549a651a61e07aaec320f
    revision 1
}
#a new data table begin:
cm cert /Common/dtdi.crt {
    cache-path /config/filestore/files_d/Common_d/trust_certificate_d/:Common:dtdi.crt_61183_1
    checksum SHA1:1220:5a13cbea2ea8df7b37dedbc52899b172547bfa47
    revision 1
}
#a new data table begin:
cm device /Common/bigip1 {
    active-modules { "BIG-IP, VE Trial|FJZMNDN-FPWCPAL|Rate Shaping|External Interface and Network HSM, VE|SDN Services, VE|SSL, Forward Proxy, VE|BIG-IP VE, Multicast Routing|APM, Limited|SSL, VE|DNS (1K QPS), VE|Routing Bundle, VE|ASM, VE|Crytpo Offload, VE, Tier 1 (25M - 200M)|Max Compression, VE|AFM, VE|DNSSEC|Anti-Virus Checks|Base Endpoint Security Checks|Firewall Checks|Network Access|Secure Virtual Keyboard|APM, Web Application|Machine Certificate Checks|Protected Workspace|Remote Desktop|App Tunnel|VE, Carrier Grade NAT (AFM ONLY)|PSM, VE|Advanced Web Application Firewall, VE" }
    base-mac 00:50:09:00:06:00
    build 0.0.9
    cert /Common/dtdi.crt
    chassis-id 0709d639-2162-4a87-470a64098152
    configsync-ip 1.1.1.1
    edition "Point Release 6"
    hostname bigip1
    key /Common/dtdi.key
    management-ip 10.12.32.61
    marketing-name "BIG-IP Virtual Edition"
    mirror-ip 1.1.1.1
    mirror-secondary-ip 10.10.10.10
    multicast-ip any
    platform-id Z100
    product BIG-IP
    self-device true
    time-zone America/Los_Angeles
    unicast-address {
        {
            effective-ip 1.1.1.1
            effective-port 1026
            ip 1.1.1.1
        }
    }
    version 14.1.0.6
}
#a new data table begin:
cm device-group /Common/Ha {
    description Hashuangji
    devices {
        /Common/bigip1 { }
    }
    network-failover disabled
}
#a new data table begin:
cm device-group /Common/device_trust_group {
    auto-sync enabled
    devices {
        /Common/bigip1 { }
    }
    hidden true
    network-failover disabled
}
#a new data table begin:
cm device-group /Common/gtm {
    devices {
        /Common/bigip1 { }
    }
    hidden true
    network-failover disabled
}
#a new data table begin:
cm key /Common/dtca.key {
    cache-path /config/filestore/files_d/Common_d/trust_certificate_key_d/:Common:dtca.key_61189_1
    checksum SHA1:1704:443f06c5e8bd4bfa0199b39dc8d54bd45f2cec65
    revision 1
}
#a new data table begin:
cm key /Common/dtdi.key {
    cache-path /config/filestore/files_d/Common_d/trust_certificate_key_d/:Common:dtdi.key_61185_1
    checksum SHA1:1704:2c69f8d3eb0363a4c3e5b864d25c2d9220ad4f70
    revision 1
}
#a new data table begin:
cm traffic-group /Common/traffic-group-1 {
    unit-id 1
}
#a new data table begin:
cm traffic-group /Common/traffic-group-local-only { }
#a new data table begin:
cm trust-domain /Common/Root {
    ca-cert /Common/dtca.crt
    ca-cert-bundle /Common/dtca-bundle.crt
    ca-devices { /Common/bigip1 }
    ca-key /Common/dtca.key
    guid 7955ac52-eb61-4b2e-bac4005002000300
    status standalone
    trust-group /Common/device_trust_group
}
#a new data table begin:
net interface 1.1 {
    media-fixed 10000T-FD
}
#a new data table begin:
net interface 1.2 {
    media-fixed 10000T-FD
}
#a new data table begin:
net interface 1.3 {
    media-fixed 10000T-FD
}
#a new data table begin:
net interface 1.4 {
    media-fixed 10000T-FD
}
#a new data table begin:
net port-list /Common/_sys_self_allow_tcp_defaults {
    ports {
        22 { }
        53 { }
        161 { }
        443 { }
        1029-1043 { }
        4353 { }
    }
}
#a new data table begin:
net port-list /Common/_sys_self_allow_udp_defaults {
    ports {
        53 { }
        161 { }
        520 { }
        1026 { }
        4353 { }
    }
}
#a new data table begin:
net route-domain /Common/0 {
    id 0
    vlans {
        /Common/vlan_5
        /Common/http-tunnel
        /Common/socks-tunnel
        /Common/vlan_7
    }
}
#a new data table begin:
net self /Common/floating {
    address 1.1.1.2/24
    allow-service {
        default
    }
    traffic-group /Common/traffic-group-1
    vlan /Common/vlan_5
}
#a new data table begin:
net self /Common/float {
    address 1.1.1.1/24
    traffic-group /Common/traffic-group-local-only
    vlan /Common/vlan_5
}
#a new data table begin:
net self /Common/floatip {
    address 10.10.10.10/24
    allow-service {
        default
    }
    traffic-group /Common/traffic-group-local-only
    vlan /Common/vlan_5
}
#a new data table begin:
net self /Common/21.86.117.105 {
    address 21.86.117.105/24
    allow-service all
    traffic-group none
    vlan /Common/vlan_7
}
#a new data table begin:
net self-allow {
    defaults {
        igmp:0
        ospf:0
        pim:0
        tcp:161
        tcp:22
        tcp:4353
        tcp:443
        tcp:53
        udp:1026
        udp:161
        udp:4353
        udp:520
        udp:53
    }
}
#a new data table begin:
net stp /Common/cist {
    interfaces {
        1.1 {
            external-path-cost 200000
            internal-path-cost 200000
        }
    }
    trunks {
        trunk {
            external-path-cost 200000
            internal-path-cost 200000
        }
    }
    vlans {
        /Common/vlan_5
        /Common/vlan_7
    }
}
#a new data table begin:
net trunk trunk {
    interfaces {
        1.2
        1.3
    }
}
#a new data table begin:
net vlan /Common/vlan_5 {
    description trunk_vlan_5
    interfaces {
        trunk {
            tagged
        }
    }
    sflow {
        poll-interval-global no
        sampling-rate-global no
    }
    tag 5
}
#a new data table begin:
net vlan /Common/vlan_7 {
    description vlan_7
    interfaces {
        1.1 { }
    }
    sflow {
        poll-interval-global no
        sampling-rate-global no
    }
    tag 4094
}
#a new data table begin:
net fdb tunnel /Common/http-tunnel { }
#a new data table begin:
net fdb tunnel /Common/socks-tunnel { }
#a new data table begin:
net fdb vlan /Common/vlan_5 { }
#a new data table begin:
net fdb vlan /Common/vlan_7 { }
#a new data table begin:
net tunnels tunnel /Common/http-tunnel {
    description "Tunnel for http-explicit profile"
    profile /Common/tcp-forward
}
#a new data table begin:
net tunnels tunnel /Common/socks-tunnel {
    description "Tunnel for socks profile"
    profile /Common/tcp-forward
}
security device-id attribute /Common/att01 {
    id 1
}
security device-id attribute /Common/att02 {
    id 2
}
security device-id attribute /Common/att03 {
    id 3
}
security device-id attribute /Common/att04 {
    id 4
}
security device-id attribute /Common/att05 {
    id 5
}
security device-id attribute /Common/att06 {
    id 6
}
security device-id attribute /Common/att07 {
    id 7
}
security device-id attribute /Common/att08 {
    id 8
}
security device-id attribute /Common/att09 {
    id 9
}
security device-id attribute /Common/att10 {
    id 10
}
security device-id attribute /Common/att11 {
    id 11
}
security device-id attribute /Common/att12 {
    id 12
}
security device-id attribute /Common/att13 {
    id 13
}
security device-id attribute /Common/att14 {
    id 14
}
security device-id attribute /Common/att15 {
    id 15
}
security device-id attribute /Common/att16 {
    id 16
}
security device-id attribute /Common/att17 {
    id 17
}
security device-id attribute /Common/att18 {
    id 18
}
security device-id attribute /Common/att19 {
    id 19
}
security device-id attribute /Common/att20 {
    id 20
}
security device-id attribute /Common/att21 {
    id 21
}
security device-id attribute /Common/att22 {
    id 22
}
security device-id attribute /Common/att23 {
    id 23
}
security device-id attribute /Common/att24 {
    id 24
}
security device-id attribute /Common/att25 {
    id 25
}
security device-id attribute /Common/att26 {
    id 26
}
security device-id attribute /Common/att27 {
    id 27
}
security device-id attribute /Common/att28 {
    id 28
}
security device-id attribute /Common/att29 {
    id 29
}
security device-id attribute /Common/att30 {
    id 30
}
security device-id attribute /Common/att31 {
    id 31
}
security device-id attribute /Common/att32 {
    id 32
}
security device-id attribute /Common/att33 {
    id 33
}
security device-id attribute /Common/att34 {
    id 34
}
security device-id attribute /Common/att35 {
    id 35
}
security device-id attribute /Common/att36 {
    id 36
}
security device-id attribute /Common/att37 {
    id 37
}
security device-id attribute /Common/att38 {
    id 38
}
security device-id attribute /Common/att39 {
    id 39
}
security firewall config-entity-id /Common/uuid_entity_id {
    entity-id 5117774226905455413
}
security firewall port-list /Common/_sys_self_allow_tcp_defaults {
    ports {
        22 { }
        53 { }
        161 { }
        443 { }
        1029-1043 { }
        4353 { }
    }
}
security firewall port-list /Common/_sys_self_allow_udp_defaults {
    ports {
        53 { }
        161 { }
        520 { }
        1026 { }
        4353 { }
    }
}
security firewall rule-list /Common/_sys_self_allow_all {
    rules {
        _sys_allow_all {
            action accept
            ip-protocol any
        }
    }
}
security firewall rule-list /Common/_sys_self_allow_defaults {
    rules {
        _sys_allow_tcp_defaults {
            action accept
            ip-protocol tcp
            destination {
                port-lists {
                    /Common/_sys_self_allow_tcp_defaults
                }
            }
        }
        _sys_allow_udp_defaults {
            action accept
            ip-protocol udp
            destination {
                port-lists {
                    /Common/_sys_self_allow_udp_defaults
                }
            }
        }
        _sys_allow_ospf_defaults {
            action accept
            ip-protocol ospf
        }
        _sys_allow_pim_defaults {
            action accept
            ip-protocol pim
        }
        _sys_allow_igmp_defaults {
            action accept
            ip-protocol igmp
        }
    }
}
security firewall rule-list /Common/_sys_self_allow_management {
    rules {
        _sys_allow_ssh {
            action accept
            ip-protocol tcp
            destination {
                ports {
                    22 { }
                }
            }
        }
        _sys_allow_web {
            action accept
            ip-protocol tcp
            destination {
                ports {
                    443 { }
                }
            }
        }
    }
}
security ip-intelligence policy /Common/ip-intelligence { }
security shared-objects port-list /Common/_sys_self_allow_tcp_defaults {
    ports {
        22 { }
        53 { }
        161 { }
        443 { }
        1029-1043 { }
        4353 { }
    }
}
security shared-objects port-list /Common/_sys_self_allow_udp_defaults {
    ports {
        53 { }
        161 { }
        520 { }
        1026 { }
        4353 { }
    }
}
#a new data table begin:
sys feature-module cgnat {
    disabled
}
#a new data table begin:
sys folder / {
    device-group none
    hidden false
    inherited-devicegroup false
    inherited-traffic-group false
    traffic-group /Common/traffic-group-1
}
#a new data table begin:
sys folder /Common {
    device-group none
    hidden false
    inherited-devicegroup true
    inherited-traffic-group true
    traffic-group /Common/traffic-group-1
}
#a new data table begin:
sys folder /Common/Drafts {
    device-group none
    hidden false
    inherited-devicegroup true
    inherited-traffic-group true
    traffic-group /Common/traffic-group-1
}
#a new data table begin:
sys global-settings {
    gui-setup disabled
    mgmt-dhcp dhcpv6
}
#a new data table begin:
sys management-dhcp /Common/sys-mgmt-dhcp-config {
    request-options { subnet-mask broadcast-address routers domain-name domain-name-servers host-name ntp-servers interface-mtu }
}
#a new data table begin:
sys management-ip 10.12.32.61/24 { }
#a new data table begin:
sys management-route /Common/default {
    description configured-statically
    gateway 10.12.32.254
    mtu 1500
    network default
}
#a new data table begin:
sys provision ltm {
    level nominal
}
#a new data table begin:
sys snmp {
    agent-addresses { tcp6:161 udp6:161 }
    communities {
        /Common/comm-public {
            community-name public
            source default
        }
    }
    disk-monitors {
        /Common/root {
            minspace 2000
            path /
        }
        /Common/var {
            minspace 10000
            path /var
        }
    }
    process-monitors {
        /Common/bigd {
            max-processes infinity
            process bigd
        }
        /Common/chmand {
            process chmand
        }
        /Common/httpd {
            max-processes infinity
            process httpd
        }
        /Common/mcpd {
            process mcpd
        }
        /Common/sod {
            process sod
        }
        /Common/tmm {
            max-processes infinity
            process tmm
        }
    }
}
#a new data table begin:
sys state-mirroring {
    addr 1.1.1.1
    secondary-addr 10.10.10.10
}
#a new data table begin:
sys dynad settings {
    development-mode false
}
#a new data table begin:
sys fpga firmware-config {
    type standard-balanced-fpga
}
#a new data table begin:
sys sflow global-settings http { }
#a new data table begin:
sys sflow global-settings vlan { }
#
# PRE-CONFIGURED PROFILES
#
# This file defines a pre-configured profile with all attributes defined
# and a default rule for each profile type.
# The profiles and rules are named the same as their type.
# For example, the profile of type "http" has the name "http".
# Profiles and rules in this file may be modified but not deleted.
# The file is loaded before bigip.conf.


# LTP classes have been moved to config_base.conf
# as a work-around for tmm doesn't support deleting LTP class

#-------------------------------------------------------------------------------
#a new data table begin:
net rate-shaping drop-policy fred {
    average-packet-size 1024
    fred-max-active 0
    fred-max-drop 100
    fred-min-drop 0
    inverse-weight 128
    max-probability 100
    max-threshold 9216
    min-threshold 3072
    type fred
}
#a new data table begin:
net rate-shaping drop-policy red {
   average-packet-size 1024
   fred-max-active 100
   inverse-weight 512
   max-probability 10
   max-threshold 15
   min-threshold 5
   red-hard-limit 60bytes
   type red
}
#a new data table begin:
net rate-shaping drop-policy tail {
    type tail
}
#a new data table begin:
net rate-shaping queue pfifo {
    type pfifo
}
#a new data table begin:
net rate-shaping queue sfq {
    type sfq
}
#-------------------------------------------------------------------------------
#a new data table begin:
ltm profile certificate-authority certificateauthority {
    ca-file none
    crl-file none
    authenticate-depth 9
    update-crl false
}
#a new data table begin:
ltm profile client-ssl clientssl {
    alert-timeout indefinite
    allow-dynamic-record-sizing disabled
    authenticate once
    authenticate-depth 9
    ca-file none
    cache-size 262144
    cache-timeout 3600
    cert-extension-includes { basic-constraints subject-alternative-name }
    cert-key-chain {
        default {
            cert /Common/default.crt
            chain none
            key /Common/default.key
            passphrase none
        }
    }
    cert /Common/default.crt
    chain none
    ciphers DEFAULT
    client-cert-ca none
    crl-file none
    handshake-timeout 10
    key /Common/default.key
    maximum-record-size 16384
    mod-ssl-methods disabled
    mode enabled
    options { dont-insert-empty-fragments no-tlsv1.3 }
    passphrase none
    peer-cert-mode ignore
    renegotiate-max-record-delay indefinite
    renegotiate-period indefinite
    renegotiate-size indefinite
    renegotiation enabled
    secure-renegotiation require
    strict-resume disabled
    unclean-shutdown enabled
    peer-no-renegotiate-timeout 10
}
#a new data table begin:
ltm profile client-ssl clientssl-insecure-compatible {
    cert-key-chain {
        default {
            cert /Common/default.crt
            chain none
            key /Common/default.key
            passphrase none
        }
    }
    cert /Common/default.crt
    chain none
    key /Common/default.key
    passphrase none
    ciphers ALL:!DH:!ADH:!EDH:@SPEED
    defaults-from /Common/clientssl
    inherit-certkeychain true
    renegotiation enabled
    secure-renegotiation request
}
#a new data table begin:
ltm profile client-ssl wom-default-clientssl {
    allow-non-ssl enabled
    defaults-from /Common/clientssl
    cert-key-chain {
        default {
            cert /Common/default.crt
            chain none
            key /Common/default.key
            passphrase none
        }
    }
    cert /Common/default.crt
    chain none
    key /Common/default.key
    passphrase none
    inherit-certkeychain true
}
#a new data table begin:
ltm profile client-ssl crypto-server-default-clientssl {
    defaults-from /Common/clientssl
    cert-key-chain {
        default {
            cert /Common/default.crt
            chain none
            key /Common/default.key
            passphrase none
        }
    }
    cert /Common/default.crt
    chain none
    key /Common/default.key
    passphrase none
    inherit-certkeychain true
    ciphers DHE-RSA-AES256-GCM-SHA384
    renegotiate-period 21600
    cache-size 0
}
#a new data table begin:
ltm profile client-ssl clientssl-secure {
    app-service none
    cert /Common/default.crt
    cert-key-chain {
        default {
            cert /Common/default.crt
            key /Common/default.key
        }
    }
    chain none
    ciphers ecdhe:rsa:!sslv3:!rc4:!exp:!des
    defaults-from /Common/clientssl
    inherit-certkeychain true
    key /Common/default.key
    options { no-ssl }
    passphrase none
    renegotiation disabled
}
#a new data table begin:
ltm profile client-ssl splitsession-default-clientssl {
    defaults-from /Common/clientssl
    cert-key-chain {
        default {
            cert /Common/default.crt
            chain none
            key /Common/default.key
            passphrase none
        }
    }
    cert /Common/default.crt
    chain none
    key /Common/default.key
    passphrase none
    inherit-certkeychain true
}
#a new data table begin:
ltm profile server-ssl splitsession-default-serverssl {
    defaults-from /Common/serverssl
    cert /Common/default.crt
    key /Common/default.key
    mode enabled
}
#a new data table begin:
ltm profile dns dns {
    enable-gtm yes
}
#a new data table begin:
ltm profile dns-acceleration dns-acceleration {
}
#a new data table begin:
ltm profile diameter diameter {
    persist-avp Session-Id
}
#a new data table begin:
ltm message-routing diameter profile session diametersession {
}
#a new data table begin:
ltm message-routing diameter profile router diameterrouter {
}
#a new data table begin:
ltm profile request-adapt requestadapt {
}
#a new data table begin:
ltm profile response-adapt responseadapt {
}
#a new data table begin:
ltm profile icap icap {
}
#a new data table begin:
ltm profile connector connector {
}
#a new data table begin:
ltm profile service service {
}
#a new data table begin:
ltm profile qoe qoe {
}
#a new data table begin:
ltm message-routing generic protocol genericmsg {
}
#a new data table begin:
ltm message-routing generic router messagerouter {
}
#a new data table begin:
ltm profile traffic-acceleration traffic-acceleration {
}
#a new data table begin:
ltm profile gtp gtp {
}
#a new data table begin:
ltm profile fix fix {
}
#a new data table begin:
ltm message-routing mqtt profile router mqttrouter {
}
#a new data table begin:
ltm message-routing mqtt profile session mqttsession {
}
#a new data table begin:
ltm message-routing sip profile router siprouter {
    operation-mode load-balancing
}
#a new data table begin:
ltm message-routing sip profile router siprouter-alg {
    defaults-from /Common/siprouter
    operation-mode application-level-gateway
}
#a new data table begin:
ltm message-routing sip profile session sipsession {
    max-msg-size 65535
    generate-response-on-failure disabled
    max-forwards-check enabled
    persistence {
        persist-type session
        persist-key Call-ID
        persist-timeout 180
    }
}
#a new data table begin:
ltm message-routing sip profile session sipsession-alg {
    max-msg-size 65535
    insert-via-header disabled
    honor-via disabled
    generate-response-on-failure disabled
    max-forwards-check disabled
    persistence {
        persist-type none
    }
}
#a new data table begin:
ltm profile fasthttp fasthttp {
    client-close-timeout 5
    connpool-idle-timeout-override 0
    connpool-max-reuse 0
    connpool-max-size 2048
    connpool-min-size 0
    connpool-step 4
    header-insert none
    idle-timeout 300
    insert-xforwarded-for disabled
    layer-7 enabled
    max-header-size 32768
    max-requests 0
    mss-override 0
    reset-on-timeout enabled
    server-close-timeout 5
}
#a new data table begin:
ltm profile fastl4 fastL4 {
    idle-timeout 300
    mss-override 0
    pva-acceleration full
    reassemble-fragments disabled
    reset-on-timeout enabled
}
#a new data table begin:
ltm profile netflow netflow {}
#a new data table begin:
ltm profile fastl4 full-acceleration {
}
#a new data table begin:
ltm profile ftp ftp {}
#a new data table begin:
ltm profile tftp tftp {}
#a new data table begin:
ltm profile ipsecalg ipsecalg {
    idle-timeout 3600
    pending-ike-connection-limit 5
    initial-connection-timeout 3
}
#a new data table begin:
ltm profile html html {
    content-selection { text/html text/xhtml }
}
#a new data table begin:
ltm profile http http {
    basic-auth-realm none
    lws-width 80
    oneconnect-transformations enabled
    oneconnect-status-reuse "200 206"
    proxy-type reverse
    enforcement {
        max-header-count 64
        max-header-size 32768
        pipeline allow
        unknown-method allow
    }
    request-chunking preserve
    response-chunking selective
}
#a new data table begin:
ltm profile http http-transparent {
    basic-auth-realm none
    lws-width 80
    oneconnect-transformations enabled
    proxy-type transparent
    enforcement {
        max-header-count 32
        excess-client-headers pass-through
        excess-server-headers pass-through
        max-header-size 16384
        oversize-client-headers pass-through
        oversize-server-headers pass-through
        truncated-redirects enabled
        pipeline allow
        unknown-method allow
    }
    request-chunking preserve
    response-chunking selective
}
#a new data table begin:
ltm profile http http-explicit {
    basic-auth-realm none
    lws-width 80
    oneconnect-transformations enabled
    proxy-type explicit
    enforcement {
        max-header-count 64
        max-header-size 32768
        pipeline allow
        unknown-method allow
    }
    request-chunking preserve
    response-chunking selective
    explicit-proxy {
        route-domain /Common/0
        default-connect-handling deny
        tunnel-name /Common/http-tunnel
        ipv6 no
    }
}
#a new data table begin:
ltm profile httprouter httprouter {
}
#a new data table begin:
ltm profile http2 http2 {
    connection-idle-timeout 300
    insert-header disabled
    insert-header-name X-HTTP2
    enforce-tls-requirements enabled
    include-content-length disabled
    activation-modes { alpn }
    concurrent-streams-per-connection 10
    receive-window 32
    frame-size 2048
    write-size 16384
    header-table-size 4096
}
#a new data table begin:
ltm profile websocket websocket {
    masking selective
}
#a new data table begin:
ltm profile splitsessionclient splitsessionclient {
}
#a new data table begin:
ltm profile splitsessionserver splitsessionserver {
}
#a new data table begin:
ltm profile http-proxy-connect http-proxy-connect {
    default-state enabled
}
#a new data table begin:
ltm profile pop3 pop3 {
    activation-mode require
}
#a new data table begin:
ltm profile imap imap {
    activation-mode require
}
#a new data table begin:
ltm profile smtps smtps {
    activation-mode require
}
#a new data table begin:
ltm profile client-ldap clientldap {
    activation-mode require
}
#a new data table begin:
ltm profile server-ldap serverldap {
    activation-mode none
}
#a new data table begin:
ltm profile mqtt mqtt {
}

#a new data table begin:
ltm profile http-compression httpcompression {
    allow-http-10 disabled
    buffer-size 4096
    content-type-exclude none
    content-type-include { text/ "application/(xml|x-javascript)" }
    cpu-saver enabled
    cpu-saver-high 90
    cpu-saver-low 75
    gzip-level 1
    gzip-memory-level 8k
    gzip-window-size 16k
    keep-accept-encoding disabled
    method-prefer gzip
    min-size 1024
    selective disabled
    uri-exclude none
    uri-include { .* }
    vary-header enabled
}
#a new data table begin:
ltm profile http-compression wan-optimized-compression {
    allow-http-10 enabled
    buffer-size 131072
    defaults-from /Common/httpcompression
    gzip-level 1
    gzip-memory-level 16k
    gzip-window-size 64k
    vary-header enabled
}
#a new data table begin:
ltm profile one-connect oneconnect {
    idle-timeout-override disabled
    max-age 86400
    max-reuse 1000
    max-size 10000
    source-mask any
}
#a new data table begin:
ltm profile pptp pptp {
    include-destination-ip disabled
}
#a new data table begin:
ltm profile radius radiusLB {
    clients none
    persist-avp none
}
#a new data table begin:
ltm profile radius radiusLB-subscriber-aware {
    defaults-from /Common/radiusLB
    pem-protocol-profile-radius /Common/_sys_radius_proto_imsi
    subscriber-discovery enabled
}
#a new data table begin:
ltm profile request-log request-log {
    request-logging disabled
    response-logging disabled
}
#a new data table begin:
ltm profile rewrite rewrite {
    client-caching-type cache-css-js
    bypass-list none
    rewrite-list none
    split-tunneling false
    java-ca-file /Common/ca-bundle.crt
    java-sign-key /Common/default.key
    java-signer /Common/default.crt
}
#a new data table begin:
ltm profile ilx ilx {
}
#a new data table begin:
ltm profile rewrite rewrite-portal {
    rewrite-mode portal
    java-ca-file /Common/ca-bundle.crt
    java-sign-key /Common/default.key
    java-signer /Common/default.crt
}
#a new data table begin:
ltm profile rewrite rewrite-uri-translation {
    rewrite-mode uri-translation
}
#a new data table begin:
ltm profile rtsp rtsp {
    idle-timeout 300
}
#a new data table begin:
ltm profile server-ssl serverssl {
    alert-timeout indefinite
    authenticate once
    authenticate-depth 9
    authenticate-name none
    ca-file none
    cache-size 262144
    cache-timeout 3600
    c3d-cert-extension-includes { basic-constraints extended-key-usage key-usage subject-alternative-name }
    cert none
    chain none
    ciphers DEFAULT
    crl-file none
    handshake-timeout 10
    key none
    mod-ssl-methods disabled
    mode enabled
    options { dont-insert-empty-fragments no-tlsv1.3 }
    passphrase none
    peer-cert-mode ignore
    renegotiate-period indefinite
    renegotiate-size indefinite
    renegotiation enabled
    secure-renegotiation require-strict
    strict-resume disabled
    unclean-shutdown enabled
}
#a new data table begin:
ltm profile server-ssl apm-default-serverssl {
    ca-file /Common/ca-bundle.crt
    defaults-from /Common/serverssl
    peer-cert-mode require
    secure-renegotiation request
}
#a new data table begin:
ltm profile server-ssl serverssl-insecure-compatible {
    ciphers !EXPORT:!DH:RSA+RC4:RSA+AES:RSA+DES:RSA+3DES:ECDHE+AES:ECDHE+3DES:@SPEED
    defaults-from /Common/serverssl
    secure-renegotiation request
}
#a new data table begin:
ltm profile server-ssl wom-default-serverssl {
    defaults-from /Common/serverssl
    cert /Common/default.crt
    key /Common/default.key
    mode disabled
}
#a new data table begin:
ltm profile server-ssl crypto-client-default-serverssl {
    defaults-from /Common/serverssl
    ciphers DHE-RSA-AES256-GCM-SHA384
    cache-size 0
}
#a new data table begin:
ltm profile server-ssl pcoip-default-serverssl {
    defaults-from /Common/serverssl
    server-name pcoip-default-sni
}
#a new data table begin:
ltm profile sctp sctp {
    idle-timeout 300
    init-max-retries 8
    receive-ordered enabled
    receive-window-size 65535
    reset-on-timeout enabled
    secret default
    send-buffer-size 65536
    send-max-retries 10
    send-partial disabled
    tcp-shutdown disabled
}
#a new data table begin:
ltm profile analytics analytics {
    collect-server-latency enabled
    collect-page-load-time disabled
    collect-url disabled
    collect-ip disabled
    collect-geo disabled
    collect-user-agent disabled
    collect-http-throughput enabled
    collect-response-codes enabled
    collect-methods enabled
    collect-max-tps-and-throughput disabled
    publish-irule-statistics disabled
    collect-user-sessions disabled
    session-timeout 300
    collected-stats-internal-logging enabled
    captured-traffic-internal-logging disabled
    collected-stats-external-logging disabled
    captured-traffic-external-logging disabled
    notification-by-syslog disabled
    notification-by-snmp disabled
    notification-by-email disabled
}
#a new data table begin:
ltm profile tcp-analytics tcp-analytics {
    collected-by-client-side enabled
    collected-by-server-side disabled
    collected-stats-internal-logging enabled
    collect-nexthop disabled
    collect-continent enabled
    collect-region disabled
    collect-city disabled
    collect-post-code disabled
    collect-remote-host-ip disabled
    collect-remote-host-subnet enabled
    collect-country enabled
}
#a new data table begin:
ltm profile classification classification {
    preset /Common/ce
    irule-event on
    app-detection on
    urlcat off
}
#a new data table begin:
ltm profile classification classification_pem {
    preset /Common/ce_pem
    irule-event on
    app-detection on
    urlcat on
}
#a new data table begin:
ltm profile classification classification_apm_swg {
    preset /Common/ce_apm_swg
    irule-event off
    app-detection on
    urlcat off
}
#a new data table begin:
ltm profile sip sip {
    insert-record-route-header disabled
    insert-via-header disabled
    max-size 65535
    secure-via-header disabled
    terminate-on-bye enabled
}
#a new data table begin:
ltm profile statistics stats {
    defaults-from none
    field1 none
    field2 none
    field3 none
    field4 none
    field5 none
    field6 none
    field7 none
    field8 none
    field9 none
    field10 none
    field11 none
    field12 none
    field13 none
    field14 none
    field15 none
    field16 none
    field17 none
    field18 none
    field19 none
    field20 none
    field21 none
    field22 none
    field23 none
    field24 none
    field25 none
    field26 none
    field27 none
    field28 none
    field29 none
    field30 none
    field31 none
    field32 none
}
#a new data table begin:
ltm profile stream stream {
    source none
    target none
}
#a new data table begin:
ltm profile pcp pcp {
    announce-after-failover disabled
    announce-multicast 10
    listening-port 5351      
    map-filter-limit 1
    map-limit-per-client 65535
    map-recycle-delay 60
    max-mapping-lifetime 86400
    min-mapping-lifetime 600
    multicast-port 5350
    peer-oper-allowed disabled
    rule none
    third-party-option disabled
}
#a new data table begin:
ltm profile tcp f5-tcp-progressive {
    auto-proxy-buffer-size enabled
    auto-receive-window-size enabled
    auto-send-buffer-size enabled
    congestion-control woodside
    defaults-from /Common/tcp
    init-cwnd 16
    init-rwnd 16
    nagle auto
    proxy-buffer-high 262144
    proxy-buffer-low 196608
    push-flag auto
    receive-window-size 131072
    send-buffer-size 262144
}
#a new data table begin:
ltm profile tcp f5-tcp-wan {
    congestion-control woodside
    defaults-from /Common/tcp
    delayed-acks disabled
    minimum-rto 500
    nagle auto
    proxy-buffer-high 262144
    proxy-buffer-low 196608
    receive-window-size 131072
    send-buffer-size 262144
}
#a new data table begin:
ltm profile tcp f5-tcp-lan {
    defaults-from /Common/tcp
    init-cwnd 16
    init-rwnd 16
    minimum-rto 200
    nagle auto
    proxy-buffer-high 65535
    proxy-buffer-low 32768
    send-buffer-size 65535
}
#a new data table begin:
ltm profile tcp f5-tcp-mobile {
    congestion-control woodside
    defaults-from /Common/tcp
    init-cwnd 16
    nagle auto
    proxy-buffer-high 262144
    proxy-buffer-low 196608
    receive-window-size 131072
    send-buffer-size 262144
}
#a new data table begin:
ltm profile tcp tcp {
    abc enabled
    ack-on-push enabled
    auto-proxy-buffer-size disabled
    auto-receive-window-size disabled
    auto-send-buffer-size disabled
    close-wait-timeout 5
    cmetrics-cache enabled
    cmetrics-cache-timeout 0
    congestion-control high-speed
    deferred-accept disabled
    delayed-acks enabled
    delay-window-control disabled
    dsack disabled
    early-retransmit enabled
    ecn enabled
    enhanced-loss-recovery enabled
    fast-open enabled
    fast-open-cookie-expiration 21600
    fin-wait-timeout 5
    fin-wait-2-timeout 300
    idle-timeout 300
    init-cwnd 10
    init-rwnd 10
    ip-tos-to-client 0
    keep-alive-interval 1800
    limited-transmit enabled
    link-qos-to-client 0
    max-retrans 8
    max-segment-size 1460
    md5-signature disabled
    minimum-rto 1000
    mptcp disabled
    nagle disabled
    pkt-loss-ignore-burst 0
    pkt-loss-ignore-rate 0
    proxy-buffer-high 65535
    proxy-buffer-low 32768
    proxy-mss enabled
    proxy-options disabled
    push-flag default
    rate-pace enabled
    rate-pace-max-rate 0
    receive-window-size 65535
    reset-on-timeout enabled
    rexmt-thresh 3
    selective-acks enabled
    selective-nack disabled
    send-buffer-size 131072
    slow-start enabled
    syn-cookie-enable enabled
    syn-cookie-whitelist disabled
    syn-max-retrans 3
    syn-rto-base 3000
    tail-loss-probe enabled
    time-wait-recycle enabled
    time-wait-timeout 2000
    timestamps enabled
    verified-accept disabled
    zero-window-timeout 20000
}
#a new data table begin:
ltm profile tcp tcp-legacy {
    abc enabled
    ack-on-push enabled
    auto-proxy-buffer-size disabled
    auto-receive-window-size disabled
    auto-send-buffer-size disabled
    close-wait-timeout 5
    cmetrics-cache enabled
    cmetrics-cache-timeout 0
    congestion-control high-speed
    defaults-from /Common/tcp
    deferred-accept disabled
    delayed-acks enabled
    delay-window-control disabled
    dsack disabled
    early-retransmit disabled
    ecn disabled
    enhanced-loss-recovery disabled
    fast-open disabled
    fast-open-cookie-expiration 21600
    fin-wait-timeout 5
    fin-wait-2-timeout 300
    idle-timeout 300
    init-cwnd 3
    init-rwnd 3
    ip-tos-to-client 0
    keep-alive-interval 1800
    limited-transmit enabled
    link-qos-to-client 0
    max-retrans 8
    max-segment-size 1460
    md5-signature disabled
    minimum-rto 1000
    mptcp disabled
    nagle disabled
    pkt-loss-ignore-burst 0
    pkt-loss-ignore-rate 0
    proxy-buffer-high 49152
    proxy-buffer-low 32768
    proxy-mss enabled
    proxy-options enabled
    rate-pace disabled
    rate-pace-max-rate 0
    receive-window-size 65535
    reset-on-timeout enabled
    rexmt-thresh 3
    selective-acks enabled
    selective-nack disabled
    send-buffer-size 65535
    slow-start enabled
    syn-cookie-enable enabled
    syn-cookie-whitelist disabled
    syn-max-retrans 3
    syn-rto-base 3000
    tail-loss-probe disabled
    time-wait-recycle enabled
    time-wait-timeout 2000
    timestamps enabled
    verified-accept disabled
    zero-window-timeout 20000
}
#a new data table begin:
ltm profile tcp mptcp-mobile-optimized {
    abc disabled
    congestion-control illinois
    defaults-from /Common/tcp-legacy
    delay-window-control disabled
    delayed-acks disabled
    dsack disabled
    ecn enabled
    init-cwnd 16
    limited-transmit enabled
    mptcp enabled
    nagle enabled
    pkt-loss-ignore-burst 0
    pkt-loss-ignore-rate 0
    proxy-buffer-high 131072
    proxy-buffer-low 131072
    rate-pace enabled
    receive-window-size 131072
    reset-on-timeout disabled
    selective-acks enabled
    send-buffer-size 262144
    slow-start enabled
    syn-cookie-enable disabled
    timestamps enabled
}
#a new data table begin:
ltm profile tcp tcp-mobile-optimized {
    abc disabled
    congestion-control high-speed
    defaults-from /Common/tcp-legacy
    delay-window-control disabled
    delayed-acks disabled
    dsack disabled
    ecn enabled
    init-cwnd 16
    limited-transmit enabled
    nagle enabled
    pkt-loss-ignore-burst 0
    pkt-loss-ignore-rate 0
    proxy-buffer-high 131072
    proxy-buffer-low 131072
    receive-window-size 131072
    reset-on-timeout disabled
    selective-acks enabled
    send-buffer-size 131072
    slow-start enabled
    timestamps enabled
}
#a new data table begin:
ltm profile tcp tcp-lan-optimized {
    ack-on-push enabled
    defaults-from /Common/tcp-legacy
    nagle disabled
    proxy-buffer-high 131072
    proxy-buffer-low 98304
    receive-window-size 65535
    send-buffer-size 65535
    slow-start disabled
}
#a new data table begin:
ltm profile tcp tcp-wan-optimized {
    defaults-from /Common/tcp-legacy
    nagle enabled
    proxy-buffer-high 131072
    proxy-buffer-low 131072
    receive-window-size 65535
    selective-acks enabled
    send-buffer-size 65535
}
#a new data table begin:
ltm profile tcp wom-tcp-lan-optimized {
    cmetrics-cache disabled
    defaults-from /Common/tcp-lan-optimized
    delayed-acks disabled
    idle-timeout 600
    nagle enabled
    proxy-mss enabled
    slow-start enabled
}
#a new data table begin:
ltm profile tcp wom-tcp-wan-optimized {
    defaults-from /Common/tcp-wan-optimized
    delayed-acks disabled
    idle-timeout 600
    nagle enabled
    proxy-buffer-high 196608
    proxy-buffer-low 131072
    proxy-mss enabled
    receive-window-size 458752
    selective-nack enabled
    send-buffer-size 458752
    slow-start disabled
    zero-window-timeout 300000
    pkt-loss-ignore-burst 8
    pkt-loss-ignore-rate 10000
}
#a new data table begin:
ltm profile tcp splitsession-default-tcp {
    defaults-from /Common/tcp-wan-optimized
    delayed-acks disabled
    idle-timeout 600
    nagle enabled
    proxy-buffer-high 196608
    proxy-buffer-low 131072
    proxy-mss enabled
    receive-window-size 458752
    selective-nack enabled
    send-buffer-size 458752
    slow-start disabled
    zero-window-timeout 300000
    pkt-loss-ignore-burst 8
    pkt-loss-ignore-rate 10000
}
#a new data table begin:
ltm profile dhcpv4 dhcpv4 {
    idle-timeout 60
    default-lease-time 86400
    transaction-timeout 30
    max-hops 4
    ttl-value 0
}
#a new data table begin:
ltm profile dhcpv4 dhcpv4_fwd {
    idle-timeout 60
    default-lease-time 86400
    transaction-timeout 30
    max-hops 4
    ttl-value 0
    mode forwarding
}
#a new data table begin:
ltm profile dhcpv6 dhcpv6 {
    idle-timeout 60
    default-lease-time 86400
    transaction-timeout 30
}
#a new data table begin:
ltm profile dhcpv6 dhcpv6_fwd {
    idle-timeout 60
    default-lease-time 86400
    transaction-timeout 30
    mode forwarding
}
#a new data table begin:
ltm profile udp udp {
    idle-timeout 60
}
#a new data table begin:
ltm profile udp udp_preserve_ttl {
    idle-timeout 60
    defaults-from /Common/udp
    ip-ttl-mode preserve
}
#a new data table begin:
ltm profile udp udp_decrement_ttl {
    idle-timeout 60
    defaults-from /Common/udp
    ip-ttl-mode decrement
}
#a new data table begin:
ltm profile udp udp_gtm_dns {
    datagram-load-balancing enabled
    defaults-from /Common/udp
    idle-timeout 5
}
#a new data table begin:
ltm profile ipother ipother {
    idle-timeout 60
}

#a new data table begin:
ltm profile map-t mapt {
    defaults-from none
    ip6-prefix ::/48
    ip4-prefix 0.0.0.0/8
    ea-bits-length 32
    port-offset 6
    br-prefix ::/96
}

#a new data table begin:
ltm profile socks socks {
    protocol-versions { socks4 socks4a socks5 }
    default-connect-handling deny
    ipv6 no
    route-domain /Common/0
    tunnel-name /Common/socks-tunnel
}

#a new data table begin:
ltm profile web-acceleration optimized-acceleration {
    cache-object-max-size 67108864
    cache-object-min-size 0
    cache-size 6144
    defaults-from /Common/webacceleration
}
#a new data table begin:
ltm profile web-acceleration optimized-caching {
    cache-max-age 86400
    cache-object-max-size 2000000
    cache-object-min-size 0
    cache-size 10
    defaults-from /Common/webacceleration
}
#a new data table begin:
ltm profile web-acceleration webacceleration {
    cache-aging-rate 9
    cache-client-cache-control-mode all
    cache-insert-age-header enabled
    cache-max-age 3600
    cache-max-entries 10000
    cache-object-max-size 50000
    cache-object-min-size 500
    cache-size 100
    cache-uri-include { .* }
    cache-uri-include-override none
    cache-uri-exclude none
    cache-uri-pinned none
    metadata-cache-max-size 25
}
#a new data table begin:
ltm profile web-security websecurity { }
#a new data table begin:
ltm profile xml xml {}

#-------------------------------------------------------------------------------
#        APM internal virtual profiles.        #
#-------------------------------------------------------------------------------
#a new data table begin:
ltm profile web-acceleration apm-enduser-if-cache {
    cache-max-age 36000
    cache-max-entries 1000
    cache-object-min-size 5
    cache-object-max-size 12000000
    cache-size 50mb
    cache-client-cache-control-mode all
    cache-uri-include { .* }
    cache-uri-include-override none
    defaults-from /Common/webacceleration
}
#a new data table begin:
ltm profile tcp apm-forwarding-client-tcp {
    ack-on-push enabled
    close-wait-timeout 5
    defaults-from /Common/tcp-legacy
    deferred-accept disabled
    delayed-acks enabled
    ecn disabled
    fin-wait-timeout 5
    idle-timeout 300
    keep-alive-interval 60
    limited-transmit enabled
    max-retrans 8
    nagle enabled
    receive-window-size 65535
    reset-on-timeout enabled
    selective-acks enabled
    send-buffer-size 131072
    slow-start disabled
    syn-max-retrans 3
    time-wait-recycle enabled
    time-wait-timeout 2000
    timestamps enabled
}
#a new data table begin:
ltm profile tcp apm-forwarding-server-tcp {
    ack-on-push enabled
    close-wait-timeout 5
    defaults-from /Common/tcp-legacy
    deferred-accept disabled
    delayed-acks enabled
    ecn disabled
    fin-wait-timeout 5
    idle-timeout 300
    keep-alive-interval 60
    limited-transmit enabled
    max-retrans 8
    nagle enabled
    receive-window-size 65535
    reset-on-timeout enabled
    selective-acks enabled
    send-buffer-size 131072
    slow-start disabled
    syn-max-retrans 3
    time-wait-recycle enabled
    time-wait-timeout 2000
    timestamps enabled
}
#a new data table begin:
ltm profile fastl4 apm-forwarding-fastL4 {
    idle-timeout 7200
    defaults-from /Common/fastL4
}
#a new data table begin:
ltm profile service /Common/access-logonpage-protection-service {
    type f5-module
}
#a new data table begin:
ltm profile connector /Common/access-logonpage-protection-connector {
}
#-------------------------------------------------------------------------------

security ssh profile ssh {
    actions {
            default_actions {
            shell-action {
                control allow
                log no
            }
        }
    }
}

security dos profile dos { }

security bot-defense profile bot-defense { }
security bot-defense profile /Common/bot-defense-device-id-none {
    deviceid-mode none
    perform-challenge-in-transparent disabled
    dos-attack-strict-mitigation disabled
    api-access-strict-mitigation disabled

    class-overrides {
        "/Common/Malicious Bot" {
            mitigation {
                action none
            }
        }
        "/Common/Suspicious Browser" {
            mitigation {
                action none
            }
        }
        "/Common/Trusted Bot" {
            mitigation {
                action alarm
            }
        }
        "/Common/Untrusted Bot" {
            mitigation {
                action none
            }
        }
        "/Common/Unknown" {
            mitigation {
                action none
            }
        }
        "/Common/Browser" {
            verification {
                action none
            }
        }
        "/Common/Mobile Application" {
            verification {
                action none
            }
        }
    }
}
security bot-defense profile /Common/bot-defense-device-id-generate-before-access {
    deviceid-mode generate-before-access
    perform-challenge-in-transparent enabled
    dos-attack-strict-mitigation disabled
    api-access-strict-mitigation disabled

    class-overrides {
        "/Common/Malicious Bot" {
            mitigation {
                action none
            }
        }
        "/Common/Suspicious Browser" {
            mitigation {
                action none
            }
        }
        "/Common/Trusted Bot" {
            mitigation {
                action alarm
            }
        }
        "/Common/Untrusted Bot" {
            mitigation {
                action none
            }
        }
        "/Common/Unknown" {
            mitigation {
                action none
            }
        }
        "/Common/Browser" {
            verification {
                action none
            }
        }
        "/Common/Mobile Application" {
            verification {
                action none
            }
        }
    }
}
security bot-defense profile /Common/bot-defense-device-id-generate-after-access {
    deviceid-mode generate-after-access
    perform-challenge-in-transparent enabled
    dos-attack-strict-mitigation disabled
    api-access-strict-mitigation disabled

    class-overrides {
        "/Common/Malicious Bot" {
            mitigation {
                action none
            }
        }
        "/Common/Suspicious Browser" {
            mitigation {
                action none
            }
        }
        "/Common/Trusted Bot" {
            mitigation {
                action alarm
            }
        }
        "/Common/Untrusted Bot" {
            mitigation {
                action none
            }
        }
        "/Common/Unknown" {
            mitigation {
                action none
            }
        }
        "/Common/Browser" {
            verification {
                action none
            }
        }
        "/Common/Mobile Application" {
            verification {
                action none
            }
        }
    }
}

security bot-defense asm-profile bot_defense_asm { }
security bot-defense asm-profile bot_defense_asm_aggregated { }
security http profile http_security { }

# Specify here default values that cannot be set in firewall.xml
security anti-fraud profile antifraud {
    blocking-page {
        response-body "<html><head><title>User Blocked</title></head><body>Your user account has been blocked. Please contact customer support.</body></html>"
        response-headers "HTTP/1.1 200 OK
Cache-Control: no-cache
Pragma: no-cache
Connection: close"
    }
}

security anti-fraud profile /Common/access-logonpage-protection-datasafe {
    defaults-from /Common/antifraud
    description "Access Logon Page protection Datasafe profile"
    app-layer-encryption {
        fail-open disabled
    }
    urls {
        /my.policy* {
            include-query-string enabled
            type wildcard
            login-response {
                status-code 302
                validation enabled
            }
            parameters {
                password {
                    encrypt enabled
                    obfuscate enabled
                    substitute-value enabled
                }
                username {
                    identify-as-username enabled
                    encrypt enabled
                    obfuscate enabled
                    substitute-value enabled
                }
                _F5_challenge {
                    encrypt enabled
                    obfuscate enabled
                    substitute-value enabled
                }
                _F5_verify_password {
                    encrypt enabled
                    obfuscate enabled
                    substitute-value enabled
                }
            }
        }
    }
}

#----------- datasync local profiles -----------#

security datasync local-profile crypt-asm-dosl7 {
    buf-size 10240
    ds-area asm
    gen-pause-sec 0
    gen-timeout-sec 0
    keep-conf-files 0
    min-cpu-percent 0
    max-gen-rows infinite
    min-mem-mb 0
    offline-until-gen enabled
    rows-bulk 1
}
security datasync local-profile crypt-fpm {
    buf-size 10240
    ds-area fps
    gen-pause-sec 0
    gen-timeout-sec 0
    keep-conf-files 0
    min-cpu-percent 0
    max-gen-rows infinite
    min-mem-mb 0
    offline-until-gen enabled
    rows-bulk 1
}
security datasync local-profile cs-asm-dosl7 {
    buf-size 9437184
    ds-area asm
    gen-pause-sec 10
    gen-timeout-sec 1800
    keep-conf-files 1000
    min-cpu-percent 20
    max-gen-rows infinite
    min-mem-mb 100
    offline-until-gen enabled
    rows-bulk 5
}
security datasync local-profile cs-fpm {
    buf-size 16777216
    ds-area fps
    gen-pause-sec 10
    gen-timeout-sec 1800
    keep-conf-files 1000
    min-cpu-percent 20
    max-gen-rows infinite
    min-mem-mb 100
    offline-until-gen enabled
    rows-bulk 10
}
security datasync local-profile static-fpm {
    buf-size 204800
    ds-area fps
    gen-pause-sec 0
    gen-timeout-sec 0
    keep-conf-files 0
    min-cpu-percent 0
    max-gen-rows infinite
    min-mem-mb 0
    offline-until-gen enabled
    rows-bulk 1
}
security datasync local-profile rsa {
    buf-size 2097152
    ds-area fps
    gen-pause-sec 10
    gen-timeout-sec 1800
    keep-conf-files 0
    min-cpu-percent 20
    max-gen-rows infinite
    min-mem-mb 50
    offline-until-gen enabled
    rows-bulk 50
}
security datasync local-profile captcha {
    buf-size 524288
    ds-area asm
    gen-pause-sec 0
    gen-timeout-sec 1800
    keep-conf-files 0
    min-cpu-percent 10
    max-gen-rows infinite
    min-mem-mb 50
    offline-until-gen enabled
    rows-bulk 4
}
security datasync local-profile cs-perm-fpm {
    buf-size 1048576
    ds-area fps
    gen-pause-sec 10
    gen-timeout-sec 1800
    keep-conf-files 1000
    min-cpu-percent 20
    max-gen-rows infinite
    min-mem-mb 100
    offline-until-gen enabled
    rows-bulk 10
}
#------------- profile_persistence -------------#
#a new data table begin:
ltm persistence cookie cookie {
    cookie-name none
    expiration 0
    hash-length 0
    hash-offset 0
    method insert
    mirror disabled
}
#a new data table begin:
ltm persistence dest-addr dest_addr {
    mask none
    mirror disabled
    timeout 180
}
#a new data table begin:
ltm persistence hash hash {
    mirror disabled
    rule none
    timeout 180
}
#a new data table begin:
ltm persistence host host {
    mirror disabled
    timeout 180
}
#a new data table begin:
ltm persistence msrdp msrdp {
    has-session-dir yes
    mirror disabled
    timeout 300
}
#a new data table begin:
ltm persistence sip sip_info {
    mirror disabled
    timeout 180
}
#a new data table begin:
ltm persistence source-addr source_addr {
    map-proxies enabled
    mask none
    mirror disabled
    timeout 180
}
#a new data table begin:
ltm persistence ssl ssl {
    mirror disabled
    timeout 300
}
#a new data table begin:
ltm persistence universal universal {
    mirror disabled
    rule none
    timeout 180
}
#--------- profile_auth
#a new data table begin:
ltm auth profile krbdelegate {
    configuration none
    cookie-key abc123
    cookie-name f5auth
    credential-source http-basic-auth
    defaults-from none
    enabled yes
    type krbdelegate
}
#a new data table begin:
ltm auth profile ldap {
    configuration none
    credential-source http-basic-auth
    defaults-from none
    enabled yes
    rule /Common/_sys_auth_ldap
    type ldap
}
#a new data table begin:
ltm auth profile radius {
    configuration none
    credential-source http-basic-auth
    defaults-from none
    enabled yes
    rule /Common/_sys_auth_radius
    type radius
}
#a new data table begin:
ltm auth profile ssl_cc_ldap {
    configuration none
    defaults-from none
    enabled yes
    rule /Common/_sys_auth_ssl_cc_ldap
    type ssl-cc-ldap
}
#a new data table begin:
ltm auth profile ssl_crldp {
    configuration none
    defaults-from none
    enabled yes
    rule /Common/_sys_auth_ssl_crldp
    type ssl-crldp
}
#a new data table begin:
ltm auth profile ssl_ocsp {
    configuration none
    defaults-from none
    enabled yes
    rule /Common/_sys_auth_ssl_ocsp
    type ssl-ocsp
}
#a new data table begin:
ltm auth profile tacacs {
    configuration none
    credential-source http-basic-auth
    defaults-from none
    enabled yes
    rule /Common/_sys_auth_tacacs
    type tacacs
}
#-------------------------------------------------------------------------------
#a new data table begin:
ltm data-group internal aol {
    records {
        64.12.96.0/19 { }
        195.93.16.0/20 { }
        195.93.48.0/22 { }
        195.93.64.0/19 { }
        195.93.96.0/19 { }
        198.81.0.0/22 { }
        198.81.8.0/23 { }
        198.81.16.0/20 { }
        202.67.65.128/25 { }
        205.188.112.0/20 { }
        205.188.146.144/30 { }
        205.188.192.0/20 { }
        205.188.208.0/23 { }
        207.200.112.0/21 { }
    }
    type ip
}
#a new data table begin:
ltm data-group internal images {
    records {
        .bmp { }
        .gif { }
        .jpg { }
    }
    type string
}
#a new data table begin:
ltm data-group internal private_net {
    records {
        10.0.0.0/8 { }
        172.16.0.0/12 { }
        192.168.0.0/16 { }
    }
    type ip
}
#a new data table begin:
ltm data-group internal sys_APM_MS_Office_OFBA_DG {
    description "This internal data-group is used in _sys_APM_MS_Office_OFBA_Support irule"
    records {
        ie_sp_session_sharing_enabled {
            data 0
        }
        ie_sp_session_sharing_inactivity_timeout {
            data 60
        }
        ofba_auth_dialog_size {
            data 800x600
        }
        useragent1 {
            data "microsoft data access internet publishing provider"
        }
        useragent2 {
            data "office protocol discovery"
        }
        useragent3 {
            data "microsoft office"
        }
        useragent4 {
            data non-browser
        }
        useragent5 {
            data "msoffice 12"
        }
        useragent6 {
            data microsoft-webdav-miniredir
        }
        useragent7 {
            data webdav-miniredir
        }
        useragent9 {
            data "ms frontpage 1[23456789]"
        }
        useragent10 {
            data onenote
        }
    }
    type string
}
#-------------------------------------------------------------------------------
#a new data table begin:
ltm alg-log-profile alg_log_profile {
    end-control-channel {
        action enabled
    }
    end-data-channel {
        action enabled
    }
    inbound-transaction {
        action enabled
    }
}
#a new data table begin:
ltm lsn-log-profile lsn_log_profile {
    end-outbound-session {
        action enabled
    }
    end-inbound-session {
        action enabled
    }
    quota-exceeded {
        action enabled
    }
    errors {
        action enabled
    }
}
#-------------------------------------------------------------------------------
#a new data table begin:
ltm rule /Common/_sys_auth_ldap {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when HTTP_REQUEST {
        if {not [info exists tmm_auth_http_sids(ldap)]} {
            set tmm_auth_sid [AUTH::start pam default_ldap]
            set tmm_auth_http_sids(ldap) $tmm_auth_sid
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_sid
            }
        } else {
            set tmm_auth_sid $tmm_auth_http_sids(ldap)
        }
        AUTH::username_credential $tmm_auth_sid [HTTP::username]
        AUTH::password_credential $tmm_auth_sid [HTTP::password]
        AUTH::authenticate $tmm_auth_sid

        if {not [info exists tmm_auth_http_collect_count]} {
            HTTP::collect
            set tmm_auth_http_successes 0
            set tmm_auth_http_collect_count 1
        } else {
            incr tmm_auth_http_collect_count
        }
    }
    when AUTH_RESULT {
        if {not [info exists tmm_auth_http_sids(ldap)] or \
           ($tmm_auth_http_sids(ldap) != [AUTH::last_event_session_id]) or \
           (not [info exists tmm_auth_http_collect_count])} {
            return
        }
        if {[AUTH::status] == 0} {
            incr tmm_auth_http_successes
        }
        # If multiple auth sessions are pending and
        # one failure results in termination and this is a failure
        # or enough successes have now occurred
        if {([array size tmm_auth_http_sids] > 1) and \
            ((not [info exists tmm_auth_http_sufficient_successes] or \
             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {
            # Abort the other auth sessions
            foreach {type sid} [array get tmm_auth_http_sids] {
                unset tmm_auth_http_sids($type)
                if {($type ne "ldap") and ($sid != -1)} {
                    AUTH::abort $sid
                    incr tmm_auth_http_collect_count -1
                }
            }
        }

        # If this is the last outstanding auth then either
        # release or respond to this session
        incr tmm_auth_http_collect_count -1
        if {$tmm_auth_http_collect_count == 0} {
            unset tmm_auth_http_collect_count
            if {[AUTH::status] == 0} {
                HTTP::release
            } else {
                HTTP::respond 401
            }
        }
    }
definition-signature kzFhXHp72R2BTE+vwS9DBG2dlHsnGdWPsFSEx18DMcXyOypZi34rS+un6RpZeQ0Yib9GjXmEmIqLYQVCS9JTmcnjE0AEztcIot24B1NBVOHHAUfA7LJko7hqB9L0STfRTSbjaV13+kVDJMWYj1qcxGX7bIjzxXtPwPaDHWooxADCxmLlt9siSSYYnJqTJLcSutAJd16k+Y6lUKrcXoCl+0YIKm1CF+RUyWFsCNZxcmaOIyUqUnrLgpBinYyxb2T0MN9K/A9mXT6L+gscqHT+kAXxDJESOO1FHHvq4ld2dfK+Z6eWALvR0NGaCmYN2SEnfyZ3dfvb0ZdfWcyTqysEOw==

}
#a new data table begin:
ltm rule _sys_auth_radius {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when HTTP_REQUEST {
        if {not [info exists tmm_auth_http_sids(radius)]} {
            set tmm_auth_sid [AUTH::start pam default_radius]
            set tmm_auth_http_sids(radius) $tmm_auth_sid
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_sid
            }
        } else {
            set tmm_auth_sid $tmm_auth_http_sids(radius)
        }
        AUTH::username_credential $tmm_auth_sid [HTTP::username]
        AUTH::password_credential $tmm_auth_sid [HTTP::password]
        AUTH::authenticate $tmm_auth_sid

        if {not [info exists tmm_auth_http_collect_count]} {
            HTTP::collect
            set tmm_auth_http_successes 0
            set tmm_auth_http_collect_count 1
        } else {
            incr tmm_auth_http_collect_count
        }
    }
    when AUTH_RESULT {
        if {not [info exists tmm_auth_http_sids(radius)] or \
            ($tmm_auth_http_sids(radius) != [AUTH::last_event_session_id]) or \
            (not [info exists tmm_auth_http_collect_count])} {
            return
        }
        if {[AUTH::status] == 0} {
            incr tmm_auth_http_successes
        }
        # If multiple auth sessions are pending and
        # one failure results in termination and this is a failure
        # or enough successes have now occurred
        if {([array size tmm_auth_http_sids] > 1) and \
            ((not [info exists tmm_auth_http_sufficient_successes] or \
             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {
            # Abort the other auth sessions
            foreach {type sid} [array get tmm_auth_http_sids] {
                unset tmm_auth_http_sids($type)
                if {($type ne "radius") and ($sid != -1)} {
                    AUTH::abort $sid
                    incr tmm_auth_http_collect_count -1
                }
            }
        }
        # If this is the last outstanding auth then either
        # release or respond to this session
        incr tmm_auth_http_collect_count -1
        if {$tmm_auth_http_collect_count == 0} {
            unset tmm_auth_http_collect_count
            if { [AUTH::status] == 0 } {
                HTTP::release
            } else {
                HTTP::respond 401
            }
        }
    }
definition-signature k3ZS7fMZZN+W3HDVg2i2FWS28Mv/l0JDnym3rEGY/JOn/L71DpzEEpTvyO+wU2Oecu7XfnBpkRG5mTTGGBMOOPKXoNFdRYbXprB+DRJhG2vOcR4KnxEsKyGuOM8MxNVb9Bg6jufGsqql/vEEGJJH43RjUqYIOiMNotKbghiC3BUBQfMN6XZlP3tgXTMM1wLSxei840hKMxpCa+CKWvQcnFHKzmwD3uN1S18Dx6yzGUFLSY+OFPHsctywMPQwzrZV7slOBgRGZMQbxqQAejddagQimzGzCKb0cDqdU2X4Vu6uqx1G3Lv1cihvMFDM7pLnfi2JskZ0nxNBBZ8rOcCVPw==

}
#a new data table begin:
ltm rule _sys_auth_ssl_cc_ldap {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when CLIENT_ACCEPTED {
        set tmm_auth_ssl_cc_ldap_sid 0
        set tmm_auth_ssl_cc_ldap_done 0
    }
    when CLIENTSSL_CLIENTCERT {
        if {[SSL::cert count] == 0} {
            return
        }
        set tmm_auth_ssl_cc_ldap_done 0
        if {$tmm_auth_ssl_cc_ldap_sid == 0} {
            set tmm_auth_ssl_cc_ldap_sid [AUTH::start pam default_ssl_cc_ldap]
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_ssl_cc_ldap_sid
            }
        }
        AUTH::cert_credential $tmm_auth_ssl_cc_ldap_sid [SSL::cert 0]
        AUTH::authenticate $tmm_auth_ssl_cc_ldap_sid
        SSL::handshake hold
    }
    when CLIENTSSL_HANDSHAKE {
        set tmm_auth_ssl_cc_ldap_done 1
    }
    when AUTH_RESULT {
        if {[info exists tmm_auth_ssl_cc_ldap_sid] and \
            ($tmm_auth_ssl_cc_ldap_sid == [AUTH::last_event_session_id])} {
            set tmm_auth_status [AUTH::status]
            if {$tmm_auth_status == 0} {
                set tmm_auth_ssl_cc_ldap_done 1
                SSL::handshake resume
            } elseif {$tmm_auth_status != -1 || $tmm_auth_ssl_cc_ldap_done == 0} {
                reject
            }
        }
    }
definition-signature Ls7LEbcMGMMAy6eJsdaAn7tu3l2ROMB2XWCeLRc6GfBOiSF+EvVbQcSrl5MqklVcnQF9c4fzz+ffOPFyA9RkbicoFO2F/nr2B7NOFcuNNx3e9f/043A62ODBb6d18/IKO3hnEVwnRRBkB9SRPKc6tsHrReewPEB8TdA1eNb5JcautKEa3pbxLR76k60FS8k5wyPJ7W58gKT1tnR2n5EgM5K3wQSiCXKCONknyS2MKB6iEkk3uXSbQP0lzFCxPAPyR2JQ/ZNniC3jYghSr+M5i3KaMKjSjdsTt6fYpDxLH9Iikk5ZrtJGTJeP7P8cNQallzP7JJsB5aqui/SbFA0SFQ==

}
#a new data table begin:
ltm rule _sys_auth_ssl_ocsp {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when CLIENT_ACCEPTED {
        set tmm_auth_ssl_ocsp_sid 0
        set tmm_auth_ssl_ocsp_done 0
    }
    when CLIENTSSL_CLIENTCERT {
        if {[SSL::cert count] == 0} {
            return
        }
        set tmm_auth_ssl_ocsp_done 0
        if {$tmm_auth_ssl_ocsp_sid == 0} {
            set tmm_auth_ssl_ocsp_sid [AUTH::start pam default_ssl_ocsp]
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_ssl_ocsp_sid
            }
        }
        AUTH::cert_credential $tmm_auth_ssl_ocsp_sid [SSL::cert 0]
        AUTH::cert_issuer_credential $tmm_auth_ssl_ocsp_sid [SSL::cert issuer 0]
        AUTH::authenticate $tmm_auth_ssl_ocsp_sid
        SSL::handshake hold
    }
    when CLIENTSSL_HANDSHAKE {
        set tmm_auth_ssl_ocsp_done 1
    }
    when AUTH_RESULT {
        if {[info exists tmm_auth_ssl_ocsp_sid] and \
            ($tmm_auth_ssl_ocsp_sid == [AUTH::last_event_session_id])} {
            set tmm_auth_status [AUTH::status]
            if {$tmm_auth_status == 0} {
                set tmm_auth_ssl_ocsp_done 1
                SSL::handshake resume
            } elseif {$tmm_auth_status != -1 || $tmm_auth_ssl_ocsp_done == 0} {
                reject
            }
        }
    }
definition-signature UAbD8tfmCrHiqB/uh1XzQfJvsgT+StbJ+Zq37qc+ODGStnFwDjXroPuPGPAycPBveiky0CU9/gR24Y8zfhMzbHK2lm/WvUq7cdrVIX2ZAvIVof9PpmfWli1c9iPe8EEau0yrOD7pZeyMpYM2hIlG1L9YmhBSJGwGV2UzmKmFdLsBWuGfcfBW7ZXQTjKz0UhT4YWUbpF0ws9QNJln8zsiCPlChF2OAJk35ZxGoZmKGA/xL2fJVbsI3vz3HAbAadKx0AiXqk6aTwtQny18mu0nVsPbO5t/KwqH6C3rc/qoVgqG6FsvVen2OvNYDBnq4gm+A5Mf1abey7+edQT6KJ9ztA==

}
#a new data table begin:
ltm rule _sys_auth_ssl_crldp {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when CLIENT_ACCEPTED {
        set tmm_auth_ssl_crldp_sid 0
        set tmm_auth_ssl_crldp_done 0
    }
    when CLIENTSSL_CLIENTCERT {
        if {[SSL::cert count] == 0} {
            return
        }
        set tmm_auth_ssl_crldp_done 0
        if {$tmm_auth_ssl_crldp_sid == 0} {
            set tmm_auth_ssl_crldp_sid [AUTH::start pam default_ssl_crldp]
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_ssl_crldp_sid
            }
        }
        AUTH::cert_credential $tmm_auth_ssl_crldp_sid [SSL::cert 0]
        AUTH::cert_issuer_credential $tmm_auth_ssl_crldp_sid [SSL::cert issuer 0]
        AUTH::authenticate $tmm_auth_ssl_crldp_sid
        SSL::handshake hold
    }
    when CLIENTSSL_HANDSHAKE {
        set tmm_auth_ssl_crldp_done 1
    }
    when AUTH_RESULT {
        if {[info exists tmm_auth_ssl_crldp_sid] and \
            ($tmm_auth_ssl_crldp_sid == [AUTH::last_event_session_id])} {
            set tmm_auth_status [AUTH::status]
            if {$tmm_auth_status == 0} {
                set tmm_auth_ssl_crldp_done 1
                SSL::handshake resume
            } elseif {$tmm_auth_status != -1 || $tmm_auth_ssl_crldp_done == 0} {
                reject
            }
        }
    }
definition-signature mVtMWHPruxGXVKW3hAZn3uBJkGNB8SmyzvR6u2OrQ+U71Ms+vAVuNSzCBJ05qJ7qfouOwtUYMtB1QMSjEdnLe2Z259y4gfnrEZEDpEZX8Co1rTEoP3grsw0heuITOPIX6R+MXrqfcmbaKRGGq2wJcNPLJXY/VsdYQBPDmaPrn/ZPRbmXSdRnpGFz4yN99tOw4OE5wvkp4CRg/zfSfQeFkzLrSeApGSWWAVMT09LW6aZmOWuC2bzr7Gpc7vtJtFuka8U7jSXAMJNOzqE55qhIvA3Y7UkIYemyXD0NCXmkUEWsPsuIzmZH6k6W8cXdhHtk+YEDvJDhKNO7h/C0qKPlaA==

}
#a new data table begin:
ltm rule _sys_auth_tacacs {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when HTTP_REQUEST {
        if {not [info exists tmm_auth_http_sids(tacacs)]} {
            set tmm_auth_sid [AUTH::start pam default_tacacs]
            set tmm_auth_http_sids(tacacs) $tmm_auth_sid
            if {[info exists tmm_auth_subscription]} {
                AUTH::subscribe $tmm_auth_sid
            }
        } else {
            set tmm_auth_sid $tmm_auth_http_sids(tacacs)
        }
        AUTH::username_credential $tmm_auth_sid [HTTP::username]
        AUTH::password_credential $tmm_auth_sid [HTTP::password]
        AUTH::authenticate $tmm_auth_sid

        if {not [info exists tmm_auth_http_collect_count]} {
            HTTP::collect
            set tmm_auth_http_successes 0
            set tmm_auth_http_collect_count 1
        } else {
            incr tmm_auth_http_collect_count
        }
    }
    when AUTH_RESULT {
        if {not [info exists tmm_auth_http_sids(tacacs)] or \
            ($tmm_auth_http_sids(tacacs) != [AUTH::last_event_session_id]) or \
            (not [info exists tmm_auth_http_collect_count])} {
            return
        }
        if {[AUTH::status] == 0} {
            incr tmm_auth_http_successes
        }
        # If multiple auth sessions are pending and
        # one failure results in termination and this is a failure
        # or enough successes have now occurred
        if {([array size tmm_auth_http_sids] > 1) and \
            ((not [info exists tmm_auth_http_sufficient_successes] or \
             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {
            # Abort the other auth sessions
            foreach {type sid} [array get tmm_auth_http_sids] {
                unset tmm_auth_http_sids($type)
                if {($type ne "tacacs") and ($sid != -1)} {
                    AUTH::abort $sid
                    incr tmm_auth_http_collect_count -1
                }
            }
        }
        # If this is the last outstanding auth then either
        # release or respond to this session
        incr tmm_auth_http_collect_count -1
        if {$tmm_auth_http_collect_count == 0} {
            unset tmm_auth_http_collect_count
            if { [AUTH::status] == 0 } {
                HTTP::release
            } else {
                HTTP::respond 401
            }
        }
    }
definition-signature qR6ynw882+5gcwiV6eymN/CZAoF+G4aRd2Xfr+4KWfXAD27876SoHuTyuTKxKxcG5oGXOPppqH/vtbtnBiI+UW6CLEHne3+RPx9EaSxX4ElCg/1ap69j3xPmh2IVSTCrR/93vu9Bnt6DEkNbXelWze5C0jVwMogQdsiVpmn7+YfkSmyyEeAvx8aHkvhK8KL0Pp8AiqrvyDWcBVAtXtioS0YC3S8pxRbpWHuVzA9e4SXNIpCk8vigk7gOmQthC+xerw0/8PEmOfT4G2LNr7TG4M1kQFkLR1foz4EwODEODHjyiyNTWZsCH4sPWJM6xJXS+NbL4k+0lWNPyhnyAGbnpw==

}
#a new data table begin:
ltm rule _sys_auth_krbdelegate {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when HTTP_REQUEST {
        set thecert ""
        set ckname F5KRBAUTH
        set ckpass abc123
        set authprofiles [PROFILE::list auth]
        # Search the auth profiles for the krbdelegate(7) and grab cookie info
        foreach profname $authprofiles {
            if { [PROFILE::auth $profname type] == 7 } {
                set tmpckname [PROFILE::auth $profname cookie_name]
                set tmpckpass [PROFILE::auth $profname cookie_key]
                if {[PROFILE::auth $profname cookie_name] != "" } {
                    set ckname $tmpckname
                    set ckpass $tmpckpass
                    break
                }
            }
        }
        set seecookie 0
        set insertcookie 0
        # check for the cookie
        if {not [info exists tmm_auth_http_sids(krbdelegate)]} {
            set tmm_auth_sid [AUTH::start pam default_krbdelegate]
            set tmm_auth_http_sids(krbdelegate) $tmm_auth_sid
            AUTH::subscribe $tmm_auth_sid
        } else {
            set tmm_auth_sid $tmm_auth_http_sids(krbdelegate)
        }
        if { [PROFILE::exists clientssl] } {
            set certcmd "SSL::cert 0"
            set thecert [ eval $certcmd ]
        }
        if { $thecert == "" } {
            # if no cert, assume old kerb delegation
            # if there is no Authorization header and no cookie, get one.
            if { ([HTTP::header Authorization] == "") and
                  (not [HTTP::cookie exists $ckname])} {
                HTTP::respond 401 WWW-Authenticate Negotiate
                return
            }
        }
        if {[HTTP::cookie exists $ckname]} {
            set ckval [HTTP::cookie decrypt $ckname $ckpass]
            AUTH::username_credential $tmm_auth_sid "cookie"
            AUTH::password_credential $tmm_auth_sid $ckval
            set seecookie 1
        } else {
            if { $thecert == "" } {
                # Kerberos Delegation - set username
                # Strip off the Negotiate before the base64d goodness
                AUTH::username_credential $tmm_auth_sid [lindex [HTTP::header Authorization] 1]
            }
            else {
                # Protocol Transition - set ttm_auth_sid
                AUTH::username_credential $tmm_auth_sid "krpprottran"
                AUTH::cert_credential $tmm_auth_sid $thecert
            }
            AUTH::password_credential $tmm_auth_sid "xxxx"
        }
        AUTH::authenticate $tmm_auth_sid

        if {not [info exists tmm_auth_http_collect_count]} {
            HTTP::collect
            set tmm_auth_http_successes 0
            set tmm_auth_http_collect_count 1
        } else {
            incr tmm_auth_http_collect_count
        }
    }
    when AUTH_RESULT {
        if {not [info exists tmm_auth_http_sids(krbdelegate)] or \
            ($tmm_auth_http_sids(krbdelegate) != [AUTH::last_event_session_id]) or \
            (not [info exists tmm_auth_http_collect_count])} {
            return
        }
        if {[AUTH::status] == 0} {
            incr tmm_auth_http_successes
        }
        # If multiple auth sessions are pending and
        # one failure results in termination and this is a failure
        # or enough successes have now occurred
        if {([array size tmm_auth_http_sids] > 1) and \
            ((not [info exists tmm_auth_http_sufficient_successes] or \
             ($tmm_auth_http_successes >= $tmm_auth_http_sufficient_successes)))} {
            # Abort the other auth sessions
            foreach {type sid} [array get tmm_auth_http_sids] {
                unset tmm_auth_http_sids($type)
                if {($type ne "krbdelegate") and ($sid != -1)} {
                    AUTH::abort $sid
                    incr tmm_auth_http_collect_count -1
               }
            }
        }
        # If this is the last outstanding auth then either
        # release or respond to this session
        incr tmm_auth_http_collect_count -1
        if {$tmm_auth_http_collect_count == 0} {
            unset tmm_auth_http_collect_count
            if { [AUTH::status] == 0 } {
                array set pamout [AUTH::response_data]
                HTTP::header replace Authorization "Negotiate $pamout(krbdelegate:attr:SPNEGO)"
                if {$seecookie == 0} {
                    set insertcookie $pamout(krbdelegate:attr:KRB5CCNAME)
                }
                HTTP::release
            } else {
                HTTP::respond 401 WWW-Authenticate Negotiate "Set-Cookie" "$ckname= ; expires=Wed Dec 31 16:00:00 1969"
            }
        }
    }
    # When the response goes out, if we need to insert a cookie, do it.
    when HTTP_RESPONSE {
        if {$insertcookie != 0} {
            HTTP::cookie insert name $ckname value $insertcookie
            HTTP::cookie encrypt $ckname $ckpass
        }
    }
definition-signature KlDm5lT1k17/I3injIvybDZ6HIJC8qpdPgwUlPQ42tufrR7ZVVFvtDlDEdN4/QPtex/u1oEA6mij+N8mMc/FSy3B+jRogi7HyI/2glxNh8St/+odNp3ho6gWvTpNAS8XBIdixxCxpJYahIw5h9flJ+gZywLabCSMQAlFYoXqdpjZp5oZ/kN7/J94joR0okCRxI7fHgVLNcbXKWg+Kcuw0TJkyNWWJh1J6DeRURPzol+yo8GmCMdDia9MF68Kho8b5LWQuZIwt727OThDz0BBhAuG6oEn06GiPmPSxczJrei/k5Zd1SsJe0xpWvlLKP4vps/W8TcMhY3xwY70RP1cfQ==

}
#a new data table begin:
ltm rule _sys_https_redirect {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when HTTP_REQUEST {
       HTTP::redirect https://[getfield [HTTP::host] ":" 1][HTTP::uri]
    }
definition-signature WsYy2M6xMqvosIKIEH/FSsvhtWMe6xKOA6i7f09Hbp6tJviSRXSan9xiuI8AUXXeWwB4wU/ZVfd8OXR92fOjZY1GFyea9NoY64nZMZ3+/Yy5XuiqA1bBUNIpZNmv2/zYOhDBsO0Wg27evtJrkgU/3K0cBMIgaAM5gDjlmd1KPSPmpXgcMzNpbSuNAgw8uy5FKlFEjjSNmTzTvKy83QcFFoigAixOsq0ds9Qt2gPvQ+u/4qibvTo/mxf5LF1rDc1cWoVxwspGbC5VMt1DKjG5hRo0PAr2ES9bUyQst+30CoSULDgl3hWt9Q4S5OCKbwTHRZmglvZ12s8+Qolr56cVtQ==

}

#a new data table begin:
ltm rule _sys_APM_activesync {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when RULE_INIT {
        set static::actsync_401_http_body   "<html><title>Authentication Failed</title><body>Error: Authentication Failure</body></html>"
        set static::actsync_503_http_body   "<html><title>Service is not available</title><body>Error: Service is not available</body></html>"
        set static::ACCESS_LOG_PREFIX       "01490000:7:"
    }
    when HTTP_REQUEST {
        set http_path                       [string tolower [HTTP::path]]
        set f_clientless_mode               0

        if { $http_path == "/microsoft-server-activesync" } {
        }
        elseif { $http_path == "/autodiscover/autodiscover.xml" } {
            set f_auto_discover 1
        }
        else return

        if { ! [ info exists src_ip ] } {
            set src_ip                            [IP::remote_addr]
        }
        if { ! [ info exists PROFILE_RESTRICT_SINGLE_IP ] } {
            set PROFILE_RESTRICT_SINGLE_IP  	  1
        }
        # Only allow HTTP Basic Authentication.
        set auth_info_b64enc                ""
        set http_hdr_auth                   [HTTP::header Authorization]
        regexp -nocase {Basic (.*)} $http_hdr_auth match auth_info_b64enc
        if { $auth_info_b64enc == "" } {
            set http_hdr_auth ""
        }

        if { $http_hdr_auth == "" } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Empty/invalid HTTP Basic Authorization header"
            HTTP::respond 401 content $static::actsync_401_http_body Connection close
            return
        }

        set MRHSession_cookie               [HTTP::cookie value MRHSession]
        # Do we have valid MRHSession cookie.
        if { $MRHSession_cookie != "" } {
            if { [ACCESS::session exists -state_allow -sid $MRHSession_cookie] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie"
                # Default profile access setting is false
                if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                    return
                }
                elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie "session.user.clientip" ] ] } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP matched"
                    return
                }
                else {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP does not matched"
                }
            }
            else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie"
            }
            set MRHSession_cookie ""
            HTTP::cookie remove MRHSession
        }

        set apm_username                    [ string tolower [HTTP::username] ]
        set apm_password                    [HTTP::password]

        if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
            binary scan [md5 "$apm_password$"] H* user_hash
        } else {
            binary scan [md5 "$apm_password$src_ip"] H* user_hash
        }
        set user_key {}
        append user_key $apm_username "." $user_hash
        unset user_hash

        set f_insert_clientless_mode    0
        set apm_cookie_list             [ ACCESS::user getsid $user_key ]
        if { [ llength $apm_cookie_list ] != 0 } {
            set apm_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
            if { $apm_cookie != "" } {
                HTTP::cookie insert name MRHSession value $apm_cookie
            } else {
                set f_insert_clientless_mode 1
            }
        } else {
            set f_insert_clientless_mode 1
        }

        if { $f_insert_clientless_mode == 1 } {
            HTTP::header insert "clientless-mode" 1
            HTTP::header insert "username" $apm_username
            HTTP::header insert "password" $apm_password
        }
        unset f_insert_clientless_mode
    }
    when ACCESS_SESSION_STARTED {
        if { [ info exists user_key ] } {
            ACCESS::session data set "session.user.uuid" $user_key
            ACCESS::session data set "session.user.microsoft-exchange-client" 1
            ACCESS::session data set "session.user.activesync" 1
            if { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {
                set f_auto_discover 0
                ACCESS::session data set "session.user.microsoft-autodiscover" 1
            }
        }
    }
    when ACCESS_POLICY_COMPLETED {
        if { ! [ info exists user_key ] } {
            return
        }

        set policy_result [ACCESS::policy result]
        switch $policy_result {
        "allow" {
        }
        "deny" {
            ACCESS::respond 401 content $static::actsync_401_http_body Connection close
            ACCESS::session remove
        }
        default {
            ACCESS::respond 503 content $static::actsync_503_http_body Connection close
            ACCESS::session remove
        }
        }

        unset user_key
    }
definition-signature d3ZoP7HHzJwjxIV+zgaF0J7nh0d0e3rlE5srbLvvZXOW9mSQ4VzalGLunwQMl6rths50p6zwETao3banbrWCnI+HEBKtDy61/wFJJ3UJ6RHWPSFSFQhcJMOY4WIdSRuu0VwTlMn6vte42xe2UmTWeB7tSs/STKoOQrDy0U7c34AAG9gSRaikPJz/hi/McWRIxX4LtS+gecwXX1KXM3lB7dz1kvOYOid9h1tsmUtftpB/neqmReMch3gaWrL7ZYcEECCcHEhyW6B7hqT91r5a9VG4nlq8oQ5MLa07zwVT5HV2id5lgIfhpPSzXUJbe3SJ7wN5TThtaWhBgDIHp+CYJA==

}

#a new data table begin:
ltm rule _sys_APM_ExchangeSupport_helper {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    # The purpose of this iRule is for help the main virtual for the timing of the HTTP request retry
    # during the SSO process for OutlookAnywhere protocol request which has a Content-Length value of 1GB.

    when HTTP_REQUEST {
        #  Waiting for the first chunk of data.
        HTTP::collect 1
    }

    when HTTP_REQUEST_DATA {
        # Respond 401 and close the connection once we received the data.
        HTTP::respond 401 WWW-Authenticate NTLM Connection close
    }
definition-signature qJiKrxH5xpBJr4VoBOszXDm+lvsjXtXlGXxiExuAyMkGwnIml1ED3xohHaNWu4/2/AAwX44zX2g3sr1cFx6yQeWIZVrkllxTSSqDqB9BYiLSO1kIn15vzpnj+bqzNTkvcl9fdu6yBT3Bz5X3EfCNLByKa059NQU2l/1StKK0e/KA0cCSAOzB4sh+BVI2VPPgL2R3XqoOrdgHHEE1PnBwC9WRk5Y5XFdaowpd2rfDoYBZM2C+MIxeryxMYLinXHfHbGaug4go8VX67eskI6XxWbm2fjXTBjTjMyxt7OpA6dc6S8IA3FJawUasvexJvHrdPyul2BMGRDqa+p6ZhOLzNw==

}

#a new data table begin:
ltm rule _sys_APM_ExchangeSupport_main {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    # Global variables
    # static::POLICY_RESULT_CACHE_AUTHFAILED
    #     Administrator can set this into 1, when there is a necessity to cache failed policy result.
    #     This may be needed to avoid account locked caused by the Active Sync device when it uses wrong passwords.
    #     One possible scenario, is that when the user changes the password in Active Directory, but missed to changed in their devices.
    # Responses
    # On denied result
    #     Administrator can customize the responses to the device depends on more complex conditions when necessary.
    #     In those cases, please use ACCESS::respond command.
    #     The following is the syntax of ACCESS::respond
    #     ACCESS::respond <status code> [ content <body> ] [ <Additional Header> <Additional Header value>* ]
    #     e.g. ACCESS::respond 401 content "Error: Denied" WWW-Authenticate "basic realm=\"f5.com\"" Connection close
    when RULE_INIT {
        # Please set the following global variables for customized responses.
        set static::actsync_401_http_body "<html><title>Authentication Failured</title><body>Error: Authentication Failure</body></html>"
        set static::actsync_503_http_body "<html><title>Service is not available</title><body>Error: Service is not available</body></html>"
        set static::ACCESS_LOG_PREFIX                 "01490000:7:"

        # Second Virtual Server name for 401 NTLM responder
        set static::ACCESS_SECOND_VIRTUAL_NAME        "_ACCESS_401_NTLM_responder_HTTPS"

        set static::POLICY_INPROGRESS                 "policy_inprogress"
        set static::POLICY_AUTHFAILED                 "policy_authfailed"
        # The request with huge content length can not be used for starting ACCESS session.
        # This kind of request will be put on hold, and this iRule will try to use another
        # request to start the session. The following value is used for Outlook Anywhere.
        set static::OA_MAGIC_CONTENT_LEN              1073741824

        # Similar with OutlookAnywhere case, ACCESS can not use the request which is
        # larger then following size. This becomes an issue with application that using
        # Exchange Web Service as its main protocol such as Mac OS X applications
        # (e.g. Mail app, Microsoft Entourage, etc)
        # This kind of request will be put on hold, and this iRule will try to use another
        # request to start the session.
        set static::FIRST_BIG_POST_CONTENT_LEN        640000

        # Set it into 1 if the backend EWS handler accepts HTTP Basic Authentication.
        set static::EWS_BKEND_BASIC_AUTH              0
        # Set it into 1 if the backend RPC-over-HTTP handler accepts HTTP Basic Authentication.
        set static::RPC_OVER_HTTP_BKEND_BASIC_AUTH    0
        # The following variable controls the polling mechanism.
        set static::POLICY_RESULT_POLL_INTERVAL       250
        set static::POLICY_RESULT_POLL_MAXRETRYCYCLE  600

        # Set this global variable to 1 for caching authentication failure
        # Useful for avoiding account locked out.
        set static::POLICY_RESULT_CACHE_AUTHFAILED    0

        # set this global variable to set alternative timeout for particular session
        set static::POLICY_ALT_INACTIVITY_TIMEOUT     120

        set static::ACCESS_USERKEY_TBLNAME            "_access_userkey"


        set static::ACCESS_DEL_COOKIE_HDR_VAL         "MRHSession=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; path=/"

        log -noname accesscontrol.local1.debug "01490000:7: RPC_OVER_HTTP_BKEND_BASIC_AUTH = $static::RPC_OVER_HTTP_BKEND_BASIC_AUTH"
        log -noname accesscontrol.local1.debug "01490000:7: EWS_BKEND_BASIC_AUTH = $static::EWS_BKEND_BASIC_AUTH"
    }
    when ACCESS_ACL_ALLOWED {
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX [HTTP::method] [HTTP::uri] [HTTP::header Content-Length]"

        if { [ info exists f_rpc_over_http ] && $f_rpc_over_http == 1 }  {
            if { $static::RPC_OVER_HTTP_BKEND_BASIC_AUTH == 0 } {
                if { [ info exists f_oa_magic_content_len ] && $f_oa_magic_content_len == 1 } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Use this virtual $static::ACCESS_SECOND_VIRTUAL_NAME just once. Will be reset back after disconnection."
                    use virtual $static::ACCESS_SECOND_VIRTUAL_NAME
                }
               log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Remove HTTP Auth header"
               HTTP::header remove Authorization
            }
        }
        # MSFT Exchange's EWS request handler always requesting NTLM even the connection has been
        # already authenticated if there is a HTTP Basic Auth in the request.
        if { [ info exists f_exchange_web_service ] && $f_exchange_web_service  == 1 }  {
            if { $static::EWS_BKEND_BASIC_AUTH == 0 } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Removing HTTP Basic Authorization header"
                HTTP::header remove Authorization
            }
        }
    }

    when HTTP_REQUEST {
        set http_path                       [ string tolower [HTTP::path] ]
        set f_clientless_mode               0
        set f_alt_inactivity_timeout        0
        set f_rpc_over_http                 0
        set f_exchange_web_service          0
        set f_auto_discover                 0
        set f_activesync                    0
        set f_offline_address_book          0
        set f_availability_service          0

        #  Here put appropriate pool when necessary.
        switch -glob $http_path {
        "/rpc/rpcproxy.dll" {
            # Supports for RPC over HTTP. (Outlook Anywhere)
            set f_rpc_over_http 1
        }
        "/autodiscover/autodiscover.xml" {
            # Supports for Auto Discover protocol.
            set f_auto_discover 1
            # This request does not require long inactivity timeout.
            # Don't use this for now
            set f_alt_inactivity_timeout 0
        }
        "/microsoft-server-activesync" {
            # Supports for ActiveSync
            set f_activesync 1
        }
        "/oab/*" {
            # Supports for Offline Address Book
            set f_offline_address_book 1
        }
        "/ews/*" {
            # Support for Exchange Web Service
            # Outlook's Availability Service borrows this protocol.
            set f_exchange_web_service 1
        }
        "/as/*" {
            # Support for Availability Service.
            # do nothing for now. (Untested)
            set f_availability_service 1
        }
        default {
            return
        }
        }

        set f_reqside_set_sess_id           0
        set http_method                     [HTTP::method]
        set http_hdr_host                   [HTTP::host]
        set http_hdr_uagent                 [HTTP::header User-Agent]
        set src_ip                          [IP::remote_addr]
        set http_uri                        [HTTP::uri]
        set http_content_len                [HTTP::header Content-Length]
        set MRHSession_cookie               [HTTP::cookie value MRHSession]
        set auth_info_b64enc                ""

        if { ! [ info exists PROFILE_POLICY_TIMEOUT ] } {
            set PROFILE_POLICY_TIMEOUT            [PROFILE::access access_policy_timeout]
        }
        if { ! [ info exists PROFILE_MAX_SESS_TIMEOUT ] } {
            set PROFILE_MAX_SESS_TIMEOUT          [PROFILE::access max_session_timeout]
        }
        if { ! [ info exists PROFILE_RESTRICT_SINGLE_IP ] } {
            set PROFILE_RESTRICT_SINGLE_IP        1
        }

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX method: $http_method"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Src IP: $src_ip"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX User-Agent: $http_hdr_uagent"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP uri: $http_uri"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP len: $http_content_len"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Restrict-to-single-client-ip: $PROFILE_RESTRICT_SINGLE_IP"

        # First, do we have valid MRHSession cookie.
        if { $MRHSession_cookie != "" } {
            if { [ACCESS::session exists -state_allow -sid $MRHSession_cookie] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie"
            } else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie"
                set MRHSession_cookie ""
                HTTP::cookie remove MRHSession
            }
        }

        set http_hdr_auth [HTTP::header Authorization]
        if { [ string match -nocase {basic *} $http_hdr_auth ] != 1 } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Not basic authentication. Ignore received auth header"
            set http_hdr_auth ""
        }

        if { $http_hdr_auth == "" } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX No/Empty Auth header"
            # clean up the cookie
            if { $MRHSession_cookie == "" } {
                HTTP::respond 401 content  $static::actsync_401_http_body WWW-Authenticate "Basic realm=\"[HTTP::header Host]\"" Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection close
                return
            }
            # Do nothing if we have a valid MRHSession cookie.
        }

        set f_release_request           0
        # Optimization for clients which support cookie
        if { $MRHSession_cookie != "" } {
            # Default profile access setting is false
            if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                set f_release_request 1
            }
            elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie "session.user.clientip" ] ] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP matched"
                set f_release_request 1
            }
            else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP does not matched"
                set MRHSession_cookie ""
                HTTP::cookie remove MRHSession
            }
        }

        if { $f_release_request == 0 } {
            set apm_username [ string tolower [HTTP::username]]
            set apm_password [HTTP::password]
            if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                binary scan [md5 "$apm_password"] H* user_hash
            } else {
                binary scan [md5 "$apm_password$src_ip"] H* user_hash
            }

            set user_key    {}
            append user_key $apm_username "." $user_hash
            unset user_hash

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP Hdr Auth: $http_hdr_auth"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX apm_username: $apm_username"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX user_key = $user_key"
            set apm_cookie_list             [ ACCESS::user getsid $user_key ]
            if { [ llength $apm_cookie_list ] != 0 } {
                set apm_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
                if { $apm_cookie != "" } {
                    HTTP::cookie insert name MRHSession value $apm_cookie
                    set f_release_request 1
                }
            }
        }

        if { $http_content_len ==  $static::OA_MAGIC_CONTENT_LEN } {
            set f_oa_magic_content_len 1
        }

        set f_sleep_here 0
        set retry 1

        while { $f_release_request == 0 && $retry <=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Trying #$retry for $http_method $http_uri $http_content_len"

            # This is also going to touch the table entry timer.
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Reading $user_key from table $static::ACCESS_USERKEY_TBLNAME"

            set apm_cookie [table lookup -subtable  $static::ACCESS_USERKEY_TBLNAME -notouch $user_key]
            if { $apm_cookie != "" } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Verifying table cookie = $apm_cookie"

                # Accessing SessionDB is not that cheap. Here we are trying to check known value.
                if { $apm_cookie == "policy_authfailed" || $apm_cookie == "policy_inprogress"} {
                    # Do nothing
                } elseif  { ! [ ACCESS::session exists $apm_cookie ] } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX table cookie = $apm_cookie is out-of-sync"
                    # Table value is out of sync. Ignores it.
                    set apm_cookie ""
                }
            }

            switch $apm_cookie {
            "" {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX NO APM Cookie found"

                if { [ info exists f_oa_magic_content_len ] && $f_oa_magic_content_len == 1 } {
                    # Outlook Anywhere request comes in pair. The one with 1G payload is not usable
                    # for creating new session since 1G content-length is intended for client to upload
                    # the data when needed.
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for request with magic content-len"
                    set f_sleep_here 1
                } elseif { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 && $http_content_len > $static::FIRST_BIG_POST_CONTENT_LEN } {
                    # Here we are getting large EWS request, which can't be used for starting new session
                    # in clientless-mode. Have it here waiting for next smaller one.
                    # We are holding the request here in HTTP filter, and HTTP filter automatically
                    # clamping down the TCP window when necessary.
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for big EWS request"
                    set f_sleep_here 1
                } else {
                   set apm_cookie               "policy_inprogress"
                   set f_reqside_set_sess_id    1
                   set f_release_request        1
                }
            }
            "policy_authfailed" {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Found $user_key with AUTH_FAILED"
                HTTP::respond 401 content  $static::actsync_401_http_body
                set f_release_request 1
            }
            "policy_inprogress" {
                if { [ info exists f_activesync ] && ($f_activesync == 1) } {
                    # For ActiveSync requests, aggressively starts new session.
                    set f_reqside_set_sess_id    1
                    set f_release_request        1
                } else {
                    set f_sleep_here 1
                }
            }
            default {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Using MRHSession = $apm_cookie"
                HTTP::header insert Cookie "MRHSession=$apm_cookie"
                set f_release_request 1
            }
            }

            if { $f_reqside_set_sess_id == 1 } {
                set f_reqside_set_sess_id 0
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key=$apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT"
                set f_clientless_mode 1
                HTTP::cookie remove MRHSession
                HTTP::header insert "clientless-mode" 1
                HTTP::header insert "username" $apm_username
                HTTP::header insert "password" $apm_password
                table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT
            }

            if { $f_sleep_here == 1 } {
                set f_sleep_here 0
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Waiting  $static::POLICY_RESULT_POLL_INTERVAL ms for $http_method $http_uri"
                after  $static::POLICY_RESULT_POLL_INTERVAL
            }

            incr retry
        }

        if { $f_release_request == 0 && $retry >=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Policy did not finish in [expr { $static::POLICY_RESULT_POLL_MAXRETRYCYCLE * $static::POLICY_RESULT_POLL_INTERVAL } ] ms. Close connection for $http_method $http_uri"

            table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
            ACCESS::disable
            TCP::close
            return
        }

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Releasing request $http_method $http_uri"
    }

    when ACCESS_SESSION_STARTED {
        if { [ info exists user_key ] } {
            ACCESS::session data set "session.user.uuid" $user_key
            ACCESS::session data set "session.user.microsoft-exchange-client" 1

            if { [ info exists f_activesync ] && $f_activesync == 1 } {
                ACCESS::session data set "session.user.microsoft-activesync" 1
            }
            elseif { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {
                ACCESS::session data set "session.user.microsoft-autodiscover" 1
            }
            elseif { [ info exists f_availability_service ] && $f_availability_service == 1 } {
                ACCESS::session data set "session.user.microsoft-availabilityservice" 1
            }
            elseif { [ info exists f_rpc_over_http ] && $f_rpc_over_http == 1 } {
                ACCESS::session data set "session.user.microsoft-rpcoverhttp" 1
            }
            elseif { [ info exists f_offline_address_book ] && $f_offline_address_book == 1 } {
                ACCESS::session data set "session.user.microsoft-offlineaddressbook" 1
            }
            elseif { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 } {
                ACCESS::session data set "session.user.microsoft-exchangewebservice" 1
            }
        }
        if { [ info exists f_alt_inactivity_timeout ] && $f_alt_inactivity_timeout == 1 } {
            ACCESS::session data set "session.inactivity_timeout"  $static::POLICY_ALT_INACTIVITY_TIMEOUT
        }
    }

    when HTTP_RESPONSE {
        if { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {
            set content_len [ HTTP::header Content-Length ]
            if {  $content_len > 0 } {
                HTTP::collect $content_len
            }
        }
    }
    when HTTP_RESPONSE_DATA {
        if { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {
            if { [ regsub -line {<AuthPackage>Ntlm</AuthPackage>} [ HTTP::payload ] {<AuthPackage>Basic</AuthPackage>} payload ] != 0 } {
                HTTP::payload replace 0 $content_len $payload
            }
        }
    }
    when ACCESS_POLICY_COMPLETED {
        if { ! [ info exists user_key ] } {
            return
        }

        set user_key_value ""
        set f_delete_session 0
        set policy_result [ACCESS::policy result]
        set sid [ ACCESS::session sid ]

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX ACCESS_POLICY_COMPLETED: policy_result = \"$policy_result\" user_key = \"$user_key\" sid = \"$sid\""

        set inactivity_timeout [ACCESS::session data get "session.inactivity_timeout"]
        set max_sess_timeout [ACCESS::session data get "session.max_session_timeout"]
        if { $max_sess_timeout == "" } {
             set max_sess_timeout $PROFILE_MAX_SESS_TIMEOUT
        }

        switch $policy_result {
        "allow" {
            # We depends on this table record self-cleanup capability in order to
            # indirectly sync with session DB.
            set user_key_value $sid

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Result: Allow: $user_key => $sid $inactivity_timeout $max_sess_timeout"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX user_key_value = $user_key_value"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX sid = $sid"
        }
        "deny" {
            # When necessary the admin here can check appropriate session variable
            # and decide what response more appropriate then this default response.
            ACCESS::respond 401 content  $static::actsync_401_http_body Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection close
            if {  $static::POLICY_RESULT_CACHE_AUTHFAILED == 1 } {
                set user_key_value  $static::POLICY_AUTHFAILED
            } else {
                set f_delete_session  1
            }
        }
        default {
            ACCESS::respond 503 content  $static::actsync_503_http_body Connection close
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Got unsupported policy result for $user_key ($sid)"
            set f_delete_session  1
        }
        }
        if { $user_key_value != "" } {
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key => $user_key_value $inactivity_timeout $max_sess_timeout in table $static::ACCESS_USERKEY_TBLNAME"

           table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $user_key_value $inactivity_timeout $max_sess_timeout
        } else {
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Deleting $user_key in table $static::ACCESS_USERKEY_TBLNAME"

           table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
        }

        if { $f_delete_session == 1 } {
           ACCESS::session remove
           set f_delete_session 0
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Removing the session for $user_key."
        }
    }
definition-signature ITBkr3SVPYk5UZu6F9TDEQuWGp64htd0HDsL3WNUHQqaVbu0m1tox3dTyf9X8y1MSr2KIbUfOIovCbiSXqnWRTAnSMqESm2gwlMBNCBOxTsh3AD83JE2N08jZjnC/jjnl4HRsq71uBbyHLZiL+mp1wXDtxUBUOfh7G/NUs9BajAVgQM7Vx9/Ogs+zX6ag08CXOjWwgPL5hRezZJwZEp1AXM8YrSbyT456P6axwWsB015wqJXvwpRKWcQ7sHEvkbbd928Q3koLevE6ecByjezjphomokwmi813aA7WCNbG6Tl+3YznsYAgxn2Skv0Gq7pMfoj9QFt/a39RXGyHOhRcQ==

}

#a new data table begin:
ltm rule _sys_APM_ExchangeSupport_OA_BasicAuth {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    # Global variables
    # static::POLICY_RESULT_CACHE_AUTHFAILED
    #     Administrator can set this into 1, when there is a necessity to cache failed policy result.
    #     This may be needed to avoid account locked caused by the Active Sync device when it uses wrong passwords.
    #     One possible scenario, is that when the user changes the password in Active Directory, but missed to changed in their devices.
    # Responses
    # On denied result
    #     Administrator can customize the responses to the device depends on more complex conditions when necessary.
    #     In those cases, please use ACCESS::respond command.
    #     The following is the syntax of ACCESS::respond
    #     ACCESS::respond <status code> [ content <body> ] [ <Additional Header> <Additional Header value>* ]
    #     e.g. ACCESS::respond 401 content "Error: Denied" WWW-Authenticate "basic realm=\"f5.com\"" Connection close
    when RULE_INIT {
        # Please set the following global variables for customized responses.
        set static::actsync_401_http_body "<html><title>Authentication Failured</title><body>Error: Authentication Failure</body></html>"
        set static::actsync_503_http_body "<html><title>Service is not available</title><body>Error: Service is not available</body></html>"
        set static::ACCESS_LOG_PREFIX                 "01490000:7:"

        # Second Virtual Server name for 401 NTLM responder
        set static::ACCESS_SECOND_VIRTUAL_NAME        "_ACCESS_401_NTLM_responder_HTTPS"

        set static::POLICY_INPROGRESS                 "policy_inprogress"
        set static::POLICY_AUTHFAILED                 "policy_authfailed"
        # The request with huge content length can not be used for starting ACCESS session.
        # This kind of request will be put on hold, and this iRule will try to use another
        # request to start the session. The following value is used for Outlook Anywhere.
        set static::OA_MAGIC_CONTENT_LEN              1073741824

        # Similar with OutlookAnywhere case, ACCESS can not use the request which is
        # larger then following size. This becomes an issue with application that using
        # Exchange Web Service as its main protocol such as Mac OS X applications
        # (e.g. Mail app, Microsoft Entourage, etc)
        # This kind of request will be put on hold, and this iRule will try to use another
        # request to start the session.
        set static::FIRST_BIG_POST_CONTENT_LEN        640000

        # Set it into 1 if the backend EWS handler accepts HTTP Basic Authentication.
        set static::EWS_BKEND_BASIC_AUTH              0
        # The following variable controls the polling mechanism.
        set static::POLICY_RESULT_POLL_INTERVAL       250
        set static::POLICY_RESULT_POLL_MAXRETRYCYCLE  600

        # Set this global variable to 1 for caching authentication failure
        # Useful for avoiding account locked out.
        set static::POLICY_RESULT_CACHE_AUTHFAILED    0

        # set this global variable to set alternative timeout for particular session
        set static::POLICY_ALT_INACTIVITY_TIMEOUT     120

        set static::ACCESS_USERKEY_TBLNAME            "_access_userkey"


        set static::ACCESS_DEL_COOKIE_HDR_VAL         "MRHSession=deleted; expires=Thu, 01-Jan-1970 00:00:01 GMT; path=/"

        log -noname accesscontrol.local1.debug "01490000:7: EWS_BKEND_BASIC_AUTH = $static::EWS_BKEND_BASIC_AUTH"
    }
    when ACCESS_ACL_ALLOWED {
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX [HTTP::method] [HTTP::uri] [HTTP::header Content-Length]"

        # MSFT Exchange's EWS request handler always requesting NTLM even the connection has been
        # already authenticated if there is a HTTP Basic Auth in the request.
        if { [ info exists f_exchange_web_service ] && $f_exchange_web_service  == 1 }  {
            if { $static::EWS_BKEND_BASIC_AUTH == 0 } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Removing HTTP Basic Authorization header"
                HTTP::header remove Authorization
            }
        }
    }

    when HTTP_REQUEST {
        set http_path                       [ string tolower [HTTP::path] ]
        set f_clientless_mode               0
        set f_alt_inactivity_timeout        0
        set f_rpc_over_http                 0
        set f_exchange_web_service          0
        set f_auto_discover                 0
        set f_activesync                    0
        set f_offline_address_book          0
        set f_availability_service          0

        #  Here put appropriate pool when necessary.
        switch -glob $http_path {
        "/rpc/rpcproxy.dll" {
            # Supports for RPC over HTTP. (Outlook Anywhere)
            set f_rpc_over_http 1
        }
        "/autodiscover/autodiscover.xml" {
            # Supports for Auto Discover protocol.
            set f_auto_discover 1
            # This request does not require long inactivity timeout.
            # Don't use this for now
            set f_alt_inactivity_timeout 0
        }
        "/microsoft-server-activesync" {
            # Supports for ActiveSync
            set f_activesync 1
        }
        "/oab/*" {
            # Supports for Offline Address Book
            set f_offline_address_book 1
            # Don't use this for now
            set f_alt_inactivity_timeout 0
        }
        "/ews/*" {
            # Support for Exchange Web Service
            # Outlook's Availability Service borrows this protocol.
            set f_exchange_web_service 1
        }
        "/as/*" {
            # Support for Availability Service.
            # do nothing for now. (Untested)
            set f_availability_service 1
        }
        default {
            return
        }
        }

        set f_reqside_set_sess_id           0
        set http_method                     [HTTP::method]
        set http_hdr_host                   [HTTP::host]
        set http_hdr_uagent                 [HTTP::header User-Agent]
        set http_uri                        [HTTP::uri]
        set http_content_len                [HTTP::header Content-Length]
        set MRHSession_cookie               [HTTP::cookie value MRHSession]
        set auth_info_b64enc                ""

        if { ! [ info exists src_ip ] } {
            set src_ip                            [IP::remote_addr]
        }
        if { ! [ info exists PROFILE_POLICY_TIMEOUT ] } {
            set PROFILE_POLICY_TIMEOUT            [PROFILE::access access_policy_timeout]
        }
        if { ! [ info exists PROFILE_MAX_SESS_TIMEOUT ] } {
            set PROFILE_MAX_SESS_TIMEOUT          [PROFILE::access max_session_timeout]
        }
        if { ! [ info exists PROFILE_RESTRICT_SINGLE_IP ] } {
            set PROFILE_RESTRICT_SINGLE_IP        1
        }

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX method: $http_method"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Src IP: $src_ip"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX User-Agent: $http_hdr_uagent"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP uri: $http_uri"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP len: $http_content_len"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Restrict-to-single-client-ip: $PROFILE_RESTRICT_SINGLE_IP"

        # First, do we have valid MRHSession cookie.
        if { $MRHSession_cookie != "" } {
            if { [ACCESS::session exists -state_allow -sid $MRHSession_cookie] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie"
            } else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie"
                set MRHSession_cookie ""
                HTTP::cookie remove MRHSession
            }
        }

        set http_hdr_auth [HTTP::header Authorization]
        if { [ string match -nocase {basic *} $http_hdr_auth ] != 1 } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Not basic authentication. Ignore received auth header"
            set http_hdr_auth ""
        }

        if { $http_hdr_auth == "" } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX No/Empty Auth header"
            # clean up the cookie
            if { $MRHSession_cookie == "" } {
                HTTP::respond 401 content  $static::actsync_401_http_body WWW-Authenticate "Basic realm=\"[HTTP::header Host]\"" Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close
                return
            }
            # Do nothing if we have a valid MRHSession cookie.
        }

        set f_release_request           0
        # Optimization for clients which support cookie
        if { $MRHSession_cookie != "" } {
            # Default profile access setting is false
            if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                set f_release_request 1
            }
            elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie "session.user.clientip" ] ] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP matched"
                set f_release_request 1
            }
            else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP does not matched"
                set MRHSession_cookie ""
                HTTP::cookie remove MRHSession
            }
        }

        if { $f_release_request == 0 } {
            set apm_username [string tolower [HTTP::username]]
            set apm_password [HTTP::password]
            if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                binary scan [md5 "$apm_password"] H* user_hash
            }
            else {
                binary scan [md5 "$apm_password$src_ip"] H* user_hash
            }
            set user_key    "$apm_username.$user_hash"
            unset user_hash

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP Hdr Auth: $http_hdr_auth"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX apm_username: $apm_username"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX user_key = $user_key"
            set apm_cookie_list             [ ACCESS::user getsid $user_key ]
            if { [ llength $apm_cookie_list ] != 0 } {
                set apm_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
                if { $apm_cookie != "" } {
                    HTTP::cookie insert name MRHSession value $apm_cookie
                    set f_release_request 1
                }
            }
        }

        if { $http_content_len ==  $static::OA_MAGIC_CONTENT_LEN } {
            set f_oa_magic_content_len 1
        }

        set f_sleep_here 0
        set retry 1

        while { $f_release_request == 0 && $retry <=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Trying #$retry for $http_method $http_uri $http_content_len"

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Reading $user_key from table $static::ACCESS_USERKEY_TBLNAME"

            set apm_cookie [table lookup -subtable  $static::ACCESS_USERKEY_TBLNAME -notouch $user_key]
            if { $apm_cookie != "" } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Verifying table cookie = $apm_cookie"

                # Accessing SessionDB is not that cheap. Here we are trying to check known value.
                if { $apm_cookie == "policy_authfailed" || $apm_cookie == "policy_inprogress"} {
                    # Do nothing
                } elseif  { ! [ ACCESS::session exists $apm_cookie ] } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX table cookie = $apm_cookie is out-of-sync"
                    # Table value is out of sync. Ignores it.
                    set apm_cookie ""
                }
            }

            switch $apm_cookie {
            "" {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX NO APM Cookie found"

                if { [ info exists f_oa_magic_content_len ] && $f_oa_magic_content_len == 1 } {
                    # Outlook Anywhere request comes in pair. The one with 1G payload is not usable
                    # for creating new session since 1G content-length is intended for client to upload
                    # the data when needed.
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for request with magic content-len"
                    set f_sleep_here 1
                } elseif { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 && $http_content_len > $static::FIRST_BIG_POST_CONTENT_LEN } {
                    # Here we are getting large EWS request, which can't be used for starting new session
                    # in clientless-mode. Have it here waiting for next smaller one.
                    # We are holding the request here in HTTP filter, and HTTP filter automatically
                    # clamping down the TCP window when necessary.
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Start to wait $static::POLICY_RESULT_POLL_INTERVAL ms for big EWS request"
                    set f_sleep_here 1
                } else {
                   set apm_cookie               "policy_inprogress"
                   set f_reqside_set_sess_id    1
                   set f_release_request        1
                }
            }
            "policy_authfailed" {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Found $user_key with AUTH_FAILED"
                HTTP::respond 401 content  $static::actsync_401_http_body
                set f_release_request 1
            }
            "policy_inprogress" {
                if { [ info exists f_activesync ] && ($f_activesync == 1) } {
                    # For ActiveSync requests, aggressively starts new session.
                    set f_reqside_set_sess_id    1
                    set f_release_request        1
                } else {
                    set f_sleep_here 1
                }
            }
            default {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Using MRHSession = $apm_cookie"
                HTTP::header insert Cookie "MRHSession=$apm_cookie"
                set f_release_request 1
            }
            }

            if { $f_reqside_set_sess_id == 1 } {
                set f_reqside_set_sess_id 0
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key=$apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_POLICY_TIMEOUT"
                set f_clientless_mode 1
                HTTP::cookie remove MRHSession
                HTTP::header insert "clientless-mode" 1
                HTTP::header insert "username" $apm_username
                HTTP::header insert "password" $apm_password
                table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $apm_cookie $PROFILE_POLICY_TIMEOUT $PROFILE_POLICY_TIMEOUT
            }

            if { $f_sleep_here == 1 } {
                set f_sleep_here 0
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Waiting  $static::POLICY_RESULT_POLL_INTERVAL ms for $http_method $http_uri"
                after  $static::POLICY_RESULT_POLL_INTERVAL
            }

            incr retry
        }

        if { ($f_release_request == 0) && ($retry >=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE) } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Policy did not finish in [expr { $static::POLICY_RESULT_POLL_MAXRETRYCYCLE * $static::POLICY_RESULT_POLL_INTERVAL } ] ms. Close connection for $http_method $http_uri"

            table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
            ACCESS::disable
            TCP::close
            return
        }

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Releasing request $http_method $http_uri"
    }

    when ACCESS_SESSION_STARTED {
        if { [ info exists user_key ] } {

            ACCESS::session data set "session.user.uuid" $user_key
            ACCESS::session data set "session.user.microsoft-exchange-client" 1

            if { [ info exists f_activesync ] && $f_activesync == 1 } {
                ACCESS::session data set "session.user.microsoft-activesync" 1
            }
            elseif { [ info exists f_auto_discover ] && $f_auto_discover == 1 } {
                ACCESS::session data set "session.user.microsoft-autodiscover" 1
            }
            elseif { [ info exists f_availability_service ] && $f_availability_service == 1 } {
                ACCESS::session data set "session.user.microsoft-availabilityservice" 1
            }
            elseif { [ info exists f_rpc_over_http ] && $f_rpc_over_http == 1 } {
                ACCESS::session data set "session.user.microsoft-rpcoverhttp" 1
            }
            elseif { [ info exists f_offline_address_book ] && $f_offline_address_book == 1 } {
                ACCESS::session data set "session.user.microsoft-offlineaddressbook" 1
            }
            elseif { [ info exists f_exchange_web_service ] && $f_exchange_web_service == 1 } {
                ACCESS::session data set "session.user.microsoft-exchangewebservice" 1
            }
        }
        if { [ info exists f_alt_inactivity_timeout ] && $f_alt_inactivity_timeout == 1 } {
            ACCESS::session data set "session.inactivity_timeout"  $static::POLICY_ALT_INACTIVITY_TIMEOUT
        }
    }

    when ACCESS_POLICY_COMPLETED {
        if { ! [ info exists user_key ] } {
            return
        }

        set user_key_value ""
        set f_delete_session 0
        set policy_result [ACCESS::policy result]
        set sid [ ACCESS::session sid ]

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX ACCESS_POLICY_COMPLETED: policy_result = \"$policy_result\" user_key = \"$user_key\" sid = \"$sid\""

        set inactivity_timeout [ACCESS::session data get "session.inactivity_timeout"]
        set max_sess_timeout [ACCESS::session data get "session.max_session_timeout"]
        if { $max_sess_timeout == "" } {
             set max_sess_timeout $PROFILE_MAX_SESS_TIMEOUT
        }

        switch $policy_result {
        "allow" {
            # We depends on this table record self-cleanup capability in order to
            # indirectly sync with session DB.
            set user_key_value $sid

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Result: Allow: $user_key => $sid $inactivity_timeout $max_sess_timeout"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX user_key_value = $user_key_value"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX sid = $sid"
        }
        "deny" {
            # When necessary the admin here can check appropriate session variable
            # and decide what response more appropriate then this default response.
            ACCESS::respond 401 content  $static::actsync_401_http_body Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close
            if {  $static::POLICY_RESULT_CACHE_AUTHFAILED == 1 } {
                set user_key_value  $static::POLICY_AUTHFAILED
            } else {
                set f_delete_session  1
            }
        }
        default {
            ACCESS::respond 503 content  $static::actsync_503_http_body Connection Close
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Got unsupported policy result for $user_key ($sid)"
            set f_delete_session  1
        }
        }
        if { $user_key_value != "" } {
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key => $user_key_value $inactivity_timeout $max_sess_timeout in table $static::ACCESS_USERKEY_TBLNAME"

           table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $user_key_value $inactivity_timeout $max_sess_timeout
        } else {
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Deleting $user_key in table $static::ACCESS_USERKEY_TBLNAME"

           table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
        }

        if { $f_delete_session == 1 } {
           ACCESS::session remove
           set f_delete_session 0
           log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Removing the session for $user_key."
        }
    }
definition-signature B1IR2MLC4VSVVTAxgOlbnmxBXZrz7g/jBySWM+WsjwfY8sVY/+/Ss7wZpem7Aotnw3BZdtj14KQPUeSPb1WiMAKc3GxZ0NeWzg/YjbfiJ8ebLTGun9QozSqorwv93+L9UU2Rn1T/hS8kx2peJdCFBm0FVkvVTHrGV88gZhwc77dSZzWm4ynA01qwjYn2WGDztLUpn5Cdx3XSS25sNBINe4QHeJ+7uT8DKl/psLHNT7kk7vJ3Z3uAJJIKCx434KaYTDu0OmNrLk1Rt1R+Ha3Nd+ifGdRYIZrZfYNtr0YIXErzvVlUwrvcF/OHtiLbpgVzerliIOY9VwXBngOGli444Q==

}

#a new data table begin:
ltm rule _sys_APM_ExchangeSupport_OA_NtlmAuth {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when RULE_INIT {
        set static::POLICY_INPROGRESS                 "policy_inprogress"
        set static::POLICY_FAILED                     "policy_failed"
        set static::POLICY_SUCCEED                    "policy_succeed"
        set static::POLICY_DONE_WAIT_SEC              5

        set static::FIRST_BIG_POST_CONTENT_LEN        640000
        set static::POLICY_RESULT_POLL_INTERVAL       100
        set static::POLICY_RESULT_POLL_MAXRETRYCYCLE  100
        set static::ACCESS_USERKEY_TBLNAME            "_access_userkey"
        set static::ACCESS_LOG_PREFIX                 "01490000:7:"

        set static::USE_NTLM_AUTH                     0
        set static::USE_BASIC_AUTH                    1
        set static::USE_NTLM_BASIC_AUTH               2

        set static::URL_DEFAULT                       0
        set static::URL_RPC_OVER_HTTP                 1
        set static::URL_AUTODISCOVER                  2
        set static::URL_ACTIVE_SYNC                   3
        set static::URL_OFFLINEADDRESSBOOK            4
        set static::URL_EXCHANGEWEBSERVICE            5

        set static::RECVD_AUTH_NONE                   0
        set static::RECVD_AUTH_NTLM                   1
        set static::RECVD_AUTH_BASIC                  2

        set static::ACCESS_DEL_COOKIE_HDR_VAL         "MRHSession=deleted; \
                                                       expires=Thu, 01-Jan-1970 00:00:01 GMT;\
                                                       path=/"

    }

    when HTTP_REQUEST {
        set http_path                       [string tolower [HTTP::path]]
        set url_path                        $static::URL_DEFAULT
        set use_auth                        $static::USE_NTLM_AUTH
        set f_disable_sso                   0

        switch -glob $http_path {
        "/rpc/rpcproxy.dll" {
            set url_path                    $static::URL_RPC_OVER_HTTP
        }
        "/autodiscover/autodiscover.xml" {
            set url_path                    $static::URL_ACTIVE_SYNC
            # Need to support both NTLM and Basic authentication for this URL
            set use_auth                    $static::USE_NTLM_BASIC_AUTH
        }
        "/microsoft-server-activesync*" {
            set url_path                    $static::URL_ACTIVE_SYNC
            # Use only Basic authentication for this URL
            set use_auth                    $static::USE_BASIC_AUTH
            set f_disable_sso               1
        }
        "/oab*" {
            set url_path                    $static::URL_OFFLINEADDRESSBOOK
        }
        "/ews*" {
            set url_path                    $static::URL_EXCHANGEWEBSERVICE
        }
        default {
            ECA::disable
            return
        }
        }

        if { ! [ info exists f_ntlm_auth_succeed ] } {
            set f_ntlm_auth_succeed         0
        }
        if { ! [ info exists sid_cache ] } {
            set sid_cache                         ""
        }
        if { ! [ info exists PROFILE_POLICY_TIMEOUT ] } { 
            set PROFILE_POLICY_TIMEOUT            [PROFILE::access access_policy_timeout]
        }
        if { ! [ info exists PROFILE_MAX_SESS_TIMEOUT ] } {
            set PROFILE_MAX_SESS_TIMEOUT          [PROFILE::access max_session_timeout]
        }
        if { ! [ info exists src_ip ] } {
            set src_ip                            [IP::remote_addr]
        }
        if { ! [ info exists PROFILE_RESTRICT_SINGLE_IP ] } {
            set PROFILE_RESTRICT_SINGLE_IP        1
        }

        set http_method                     [HTTP::method]
        set http_hdr_host                   [HTTP::host]
        set http_hdr_uagent                 [HTTP::header User-Agent]
        set http_uri                        [HTTP::uri]
        set http_content_len                [HTTP::header Content-Length]
        set MRHSession_cookie               [HTTP::cookie value MRHSession]

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX method:      $http_method"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Src IP:      $src_ip"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX User-Agent:  $http_hdr_uagent"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP uri:    $http_uri"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP len:    $http_content_len"

        if { ! [ info exists ECA_METADATA_ARG ] } {
            # Generating argument for ECA::metadata
            # The NTLM configuration name is derived from assigned virtual name with the algorithm as follows:
            # <virtual-fullpath> ::= <folder-path>"/"<virtual-basename> as "/" is the last "/" char.
            # <config-fullpath>  ::= <folder-path>"/" "exch_ntlm" "_" <virtual-basename>
            # e.g.  Let us say the virtual name is "/prod/exch/vs1", The folder path is "/prod/exch/",
            #       then object name will be "/prod/exch/exch_ntlm_vs1".
            set vs_name [virtual name]
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX virtual:     $vs_name"
            set slash_index [ string last / $vs_name ]
            if { $slash_index == -1 } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Error: the virtual name does not contain folder information"
                ACCESS::disable
                TCP::close
                return
            }
            set ECA_METADATA_ARG    "select_ntlm:"
            append ECA_METADATA_ARG [ string range $vs_name 0 $slash_index ]
            append ECA_METADATA_ARG "exch_ntlm_"
            append ECA_METADATA_ARG [ string range $vs_name [ expr { $slash_index + 1 } ] end ]
            unset slash_index
            unset vs_name
        }

        if { $use_auth == $static::USE_NTLM_AUTH } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Enable ECA: $ECA_METADATA_ARG"
            ECA::enable
            ECA::select $ECA_METADATA_ARG
            return
        } else {
            set recvd_auth                      $static::RECVD_AUTH_NONE
            set http_hdr_auth                   [HTTP::header Authorization]
            set auth_data                       [split $http_hdr_auth " "]
            if { $http_hdr_auth != "" } {
                if { [ llength $auth_data ] == 2 } {
                    set auth_scheme [ lindex $auth_data 0]
                    if { [string equal -nocase $auth_scheme "ntlm" ] == 1 } {
                        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Recv'd HTTP NTLM Authentication"
                        set recvd_auth          $static::RECVD_AUTH_NTLM
                    } elseif { [ string equal -nocase [ lindex $auth_data 0] "basic" ] == 1 } {
                        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Recv'd HTTP Basic Authentication"
                        set recvd_auth          $static::RECVD_AUTH_BASIC
                        set user                [string tolower [HTTP::username]]
                        set password            [HTTP::password]
                    }
                }
            }
            if { $use_auth == $static::USE_BASIC_AUTH } {
                if { $recvd_auth == $static::RECVD_AUTH_BASIC } {
                    # Defer the process until later
                } else {
                    HTTP::respond 401 -version 1.1 noserver WWW-Authenticate "Basic realm=\"$http_hdr_host\"" \
                                Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close
                    return
                }
            } elseif { $use_auth == $static::USE_NTLM_BASIC_AUTH } {
                if { ($recvd_auth == $static::RECVD_AUTH_NTLM) || ($f_ntlm_auth_succeed == 1) } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Enable ECA: $ECA_METADATA_ARG"
                    ECA::enable
                    ECA::select $ECA_METADATA_ARG
                    return
                } elseif { $recvd_auth == $static::RECVD_AUTH_BASIC } {
                    # Defer the process until later
                } else {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Request Authorization: NTLM + Basic"
                    HTTP::respond 401 -version 1.1 noserver WWW-Authenticate "Basic realm=\"$http_hdr_host\"" \
                                WWW-Authenticate "NTLM" Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close
                    return
                }
            }

            # Disable NTLM auth
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Disable ECA"
            ECA::disable
            # Disable KCD sso
            set f_disable_sso               1

            if { $MRHSession_cookie != "" } {
                if { [ACCESS::session exists -state_allow -sid $MRHSession_cookie] } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie"
                    # Default profile access setting is false
                    if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Release the request"
                        return
                    }
                    elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie "session.user.clientip" ] ] } {
                        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP matched. Release the request"
                        return
                    }
                    else {
                        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP does not matched"
                    }
                }
                else {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie"
                }

                set MRHSession_cookie ""
                HTTP::cookie remove MRHSession
            }

            set user_key                {}
            if { $PROFILE_RESTRICT_SINGLE_IP == 1 } {
                append user_key                    $src_ip
            }
            append user_key                 $password
            binary scan [md5 $user_key ] H* user_key
            set user_key                    "$user.$user_key"

            set apm_cookie_list             [ ACCESS::user getsid $user_key ]
            if { [ llength $apm_cookie_list ] != 0 } {
                set MRHSession_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
                if { $MRHSession_cookie != "" } {
                    HTTP::cookie remove MRHSession 
                    HTTP::cookie insert name MRHSession value $MRHSession_cookie
                    return
                }
            }

            HTTP::cookie remove MRHSession
            HTTP::header insert "clientless-mode"       1
            HTTP::header insert "username"              $user
            HTTP::header insert "password"              $password
            return
        }
    }

    when ECA_REQUEST_ALLOWED {
        set f_ntlm_auth_succeed                 1

        if { $MRHSession_cookie == "" } {
            # Retrieve from SID cache
            set MRHSession_cookie   $sid_cache
            HTTP::cookie insert name MRHSession value $sid_cache
        }

        if { $MRHSession_cookie != "" } {
            # Destroy session ID cache. This client should not need session ID cache 
            if { ($sid_cache != "") && ($sid_cache != $MRHSession_cookie) } {
                set sid_cache   ""
            }
            if { [ ACCESS::session exists -state_allow $MRHSession_cookie ] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie"
                # Default profile access setting is false
                if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Release the request"
                    return
                }
                elseif { [ IP::addr $src_ip equals [ ACCESS::session data get -sid $MRHSession_cookie "session.user.clientip" ] ] } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP matched. Release the request"
                    return
                }
                else {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX source IP does not matched"
                }
            } else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie"
            }
        }

        set MRHSession  ""
        set sid_cache   ""
        HTTP::cookie remove MRHSession

        # Build user_key
        set    user_key                 {}
        append user_key                 [string tolower [ECA::username]] "@" [ string tolower [ECA::domainname] ]
        if { $PROFILE_RESTRICT_SINGLE_IP == 0 } {
            append user_key             ":" $src_ip
        }
        append user_key                 ":" [ECA::client_machine_name]

        set apm_cookie_list             [ ACCESS::user getsid $user_key ]
        if { [ llength $apm_cookie_list ] != 0 } {
            set MRHSession_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
            if { $MRHSession_cookie != "" } {
                set sid_cache           $MRHSession_cookie
                HTTP::cookie insert name MRHSession value $MRHSession_cookie
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX APM Cookie found: $sid_cache"
                return
            }
        }
        unset apm_cookie_list

        set try                         1
        set start_policy_str            $src_ip
        append start_policy_str         [TCP::client_port]

        while { $try <=  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX NO APM Cookie found"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Trying #$try for $http_method $http_uri $http_content_len"

            if { $http_content_len > $static::FIRST_BIG_POST_CONTENT_LEN } {
                # Wait at below
            } else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX EXEC: table set -notouch -subtable  $static::ACCESS_USERKEY_TBLNAME -excl $user_key $start_policy_str $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT"
                set policy_status [table set -notouch -subtable  $static::ACCESS_USERKEY_TBLNAME -excl $user_key $start_policy_str $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT]
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX DONE: table set -notouch -subtable  $static::ACCESS_USERKEY_TBLNAME -excl $user_key $start_policy_str $PROFILE_POLICY_TIMEOUT $PROFILE_MAX_SESS_TIMEOUT"
                if { $policy_status == $start_policy_str } {
                    # ACCESS Policy has not started. Start one
                    HTTP::header insert "clientless-mode"    1
                    break
                } elseif { $policy_status == $static::POLICY_SUCCEED } {
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX table is out-of-sync retry"
                    table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
                    continue
                } elseif { $policy_status == $static::POLICY_FAILED } {
                    ACCESS::disable
                    TCP::close
                    return
                }
                # Wait at below
            }

            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Waiting  $static::POLICY_RESULT_POLL_INTERVAL ms for $http_method $http_uri"
            # Touch the entry table
            table lookup -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
            after  $static::POLICY_RESULT_POLL_INTERVAL

            set apm_cookie_list             [ ACCESS::user getsid $user_key ]
            if { [ llength $apm_cookie_list ] != 0 } {
                set MRHSession_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
                if { $MRHSession_cookie != "" } {
                    set sid_cache           $MRHSession_cookie
                    HTTP::cookie insert name MRHSession value $MRHSession_cookie
                    log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX APM Cookie found: $sid_cache"
                    return
                }
            }

            incr try
        }

        if { $try >  $static::POLICY_RESULT_POLL_MAXRETRYCYCLE } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Policy did not finish in [ expr { $static::POLICY_RESULT_POLL_MAXRETRYCYCLE * $static::POLICY_RESULT_POLL_INTERVAL } ] ms. Close connection for $http_method $http_uri"
            table delete -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key
            ACCESS::disable
            TCP::close
            return
        }

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Releasing request $http_method $http_uri"

        unset try
        unset start_policy_str
    }

    when ECA_REQUEST_DENIED {
        set f_ntlm_auth_succeed                 0
    }

    when HTTP_RESPONSE_RELEASE {
        if { ! [info exists user_key] } {
            return
        }
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP response: status:           [HTTP::status]"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP response: Server:           [HTTP::header Server]"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP response: Content-Length:   [HTTP::header Content-Length]"
        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX HTTP response: WWW-Authenticate: [HTTP::header WWW-Authenticate]"
    }

    when ACCESS_SESSION_STARTED {
        if { [ info exists user_key ] } {
            ACCESS::session data set "session.user.uuid" $user_key
            ACCESS::session data set "session.user.microsoft-exchange-client" 1
        }
    }

    when ACCESS_ACL_ALLOWED {
        if { [ info exists f_disable_sso ] && $f_disable_sso == 1 } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Disable WEBSSO"
            WEBSSO::disable
        }
    }

    when ACCESS_POLICY_COMPLETED {
        if { ! [ info exists user_key ] } {
            return
        }

        set user_key_value ""
        set f_delete_session 0
        set policy_result [ACCESS::policy result]
        set sid [ ACCESS::session sid ]

        log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX ACCESS_POLICY_COMPLETED: policy_result = \"$policy_result\" user_key = \"$user_key\" sid = \"$sid\""

        switch $policy_result {
        "allow" {
            set user_key_value          $sid
            set sid_cache               $user_key_value
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Result: Allow: $user_key"
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX sid = $sid"

        }
        "deny" {
            ACCESS::respond 401 content  $static::actsync_401_http_body Set-Cookie $static::ACCESS_DEL_COOKIE_HDR_VAL Connection Close
            set f_delete_session  1
        }
        default {
            ACCESS::respond 503 content  $static::actsync_503_http_body Connection Close
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Got unsupported policy result for $user_key ($sid)"
            set f_delete_session  1
        }
        }

        if { $f_ntlm_auth_succeed == 1 } {
            if { $user_key_value != "" } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key => $static::POLICY_SUCCEED"
                table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $static::POLICY_SUCCEED
            } else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Setting $user_key => $static::POLICY_FAILED  $static::POLICY_DONE_WAIT_SEC $static::POLICY_DONE_WAIT_SEC_in table $static::ACCESS_USERKEY_TBLNAME"
                table set -subtable  $static::ACCESS_USERKEY_TBLNAME $user_key $static::POLICY_FAILED  $static::POLICY_DONE_WAIT_SEC $static::POLICY_DONE_WAIT_SEC
            }
        }

        if { $f_delete_session == 1 } {
            ACCESS::session remove
            set f_delete_session 0
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_PREFIX Removing the session for $user_key."
        }
    }
definition-signature X6dt8EqJFS+8GoWtne8ePfboJR+q5TILymdnfjtylTpC5BikvDFsa3VI6x0V/MP0lJDJrjotJPN2GTogthp48mnmZ2yg+zLskYONNC+vv5yQKc7SLmQf2Eoe8C2CJ8crBUOmfi0f+kjj1GboTVcxNAJ+tpPwb+KKTpnic7WPHo8F/LO5Ou0T5tsls8AmIE/dU0pSKhgit1h5gA+pfKoeA66fhRDcwrSAJ9d/odE55+s/LxJxZqG0PzOVE7HHdbeDiRdRYyBMJQ54Ri/tJuhWQJF/4BYi6V7ScWZQ+fyvFAgb3rRl9xgCqQK3gKQpwLRK11s6+L+PPEQx863YHOEobA==

}

#a new data table begin:
ltm rule _sys_APM_Office365_SAML_BasicAuth {
    nowrite nodelete
# Copyright 2003-2006, 2012-2013, 2016.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
    when RULE_INIT {
        set static::ACCESS_LOG_ECP_PREFIX       "014d0002:7: ECP client"
    }
    when HTTP_REQUEST {
        set http_path            [string tolower [HTTP::path]]
        set http_hdr_auth        [HTTP::header Authorization]
        set http_hdr_client_app  [HTTP::header X-MS-Client-Application]
        set http_hdr_client_ip   [HTTP::header X-MS-Forwarded-Client-IP]
        set MRHSession_cookie    [HTTP::cookie value MRHSession]

        if { ($http_path == "/saml/idp/profile/redirectorpost/sso") &&
             ($http_hdr_client_app != "") &&
             ($http_hdr_client_app contains "Microsoft.Exchange") } {
            HTTP::uri "/saml/idp/profile/ecp/sso"
        } elseif { ($http_path != "/saml/idp/profile/ecp/sso")  } {
            return
        }
        set f_saml_ecp_request 1
        unset http_path

        # If MRHSession cookie from client is present, skip further processing.
        if { $MRHSession_cookie != "" } {
            if { [ACCESS::session exists -state_allow -sid $MRHSession_cookie] } {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_ECP_PREFIX HTTP *VALID* MRHSession cookie: $MRHSession_cookie"
            } else {
                log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_ECP_PREFIX HTTP *INVALID* MRHSession cookie: $MRHSession_cookie"
            }
            return
        }

        if { ($http_hdr_client_app != "") &&
            ($http_hdr_client_app contains "Microsoft.Exchange") &&
            ($http_hdr_client_ip != "") } {
	    set src_ip $http_hdr_client_ip
	}
        unset http_hdr_client_app
        unset http_hdr_client_ip

        if { ! [ info exists src_ip ] } {
            set src_ip          [IP::remote_addr]
        }

        # Only allow HTTP Basic Authentication.
        if { ($http_hdr_auth == "") || ([ string match -nocase {basic *} $http_hdr_auth ] != 1 ) } {
            log -noname accesscontrol.local1.debug "$static::ACCESS_LOG_ECP_PREFIX ECP request does not contain HTTP Basic Authorization header."
            unset http_hdr_auth
            return
        }

        set apm_username        [ string tolower [HTTP::username] ]
        set apm_password        [HTTP::password]

        binary scan [md5 "$apm_password$src_ip"] H* user_hash
        set user_key {}
        append user_key $apm_username "." $user_hash
        unset user_hash

        set apm_cookie_list             [ ACCESS::user getsid $user_key ]
        if { [ llength $apm_cookie_list ] != 0 } {
            set apm_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]
            if { $apm_cookie != "" } {
                HTTP::cookie insert name MRHSession value $apm_cookie
            }
        }

        HTTP::header insert "clientless-mode" 1
        HTTP::header insert "username" $apm_username
        HTTP::header insert "password" $apm_password
        unset apm_username
        unset apm_password
        unset http_hdr_auth
    }

    when ACCESS_SESSION_STARTED {
        if { [ info exists f_saml_ecp_request ] && $f_saml_ecp_request == 1 } {
            if { [ info exists user_key ] } {
                ACCESS::session data set "session.user.uuid" $user_key
            }
            if { [ info exists  src_ip ] } {
                ACCESS::session data set "session.user.clientip" $src_ip
            }
        }
    }

    when HTTP_RESPONSE {
        if { [ info exists f_saml_ecp_request ] && $f_saml_ecp_request == 1 } {
            unset f_saml_ecp_request
            unset apm_cookie
        }
    }
definition-signature lbhM9rFH3R+uo+pp4DWotUdvGbvFhCBhe5aZKgpRZdl5k39X50MrrIhz2UkjY1VV2JORwPaSpdyN6mVY0cJccFdLjGgaNCtNuMoT2grlOE7F9Zw73imFGbu8UiqmZT0ZLcNXCglZplp08o9O9xn7UNJ5E/gYWrjCI2QaebwGu1NMSLK+/WjGHNKr28xN2Cwo0rk9hg+6fC9YxzlGVoRlxPuYRelygqD0bAQKTux4tuTQPF/4CDNpttyVX72ULJpZUINwW1UeCZoosB1O4XubT9PaqEl53ioom8LcGZEn5vKOH+TlvKXjPi5kV1ci2d+fjCf7ZoOW6EVyEEc2aL2cWw==

}

#a new data table begin:
ltm rule _sys_APM_MS_Office_OFBA_Support {
    nowrite nodelete
# Copyright 2003-2006, 2012, 2016-2017.  F5 Networks, Inc.  See End User License Agreement ("EULA")
# for license terms. Notwithstanding anything to the contrary in the EULA,
# Licensee may copy and modify this software product for its internal business
# purposes. Further, Licensee may upload, publish and distribute the modified
# version of the software product on devcentral.f5.com.
#
# Supporting MS-OFBA protocol for native office applications.
# sys_APM_MS_Office_OFBA_DG - iRule data group to customize ofba user agent strings and
#                     few other parameters.
#
# sys_APM_MS_Office_OFBA_DG::useragent - useragent strings are mandatory, 
#       these strings are used to detect OFBA clients. All user agent strings should start
#       with useragent name, for e.g: useragent1, useragent2.. etc.
#
# sys_APM_MS_Office_OFBA_DG::ie_sp_session_sharing_enabled - Parameter to specify whether to enable or
#       disable IE session sharing using persistent cookie named "MRHSOffice".
#       Default is disabled (0), value can be 0 or 1
#     
# sys_APM_MS_Office_OFBA_DG::ie_sp_session_sharing_inactivity_timeout - inactivity timeout value 
#       for the persistent cookie value "MRHSOffice"
#       everytime, the SharePoint site refreshes or gets any response from
#       SharePoint Server.  Value can be any positive value given in seconds.
#       Default value as 60 secs
#
# sys_APM_MS_Office_OFBA_DG::ofba_auth_dialog_size - OFBA dialog browser
#       resolution size given as widthxheight, default 800x600
#
# static::MS_OFBA_ENABLED_CLIENT_TYPE - "ms-ofba-compliant" session variable
#       value that can be used in Access policy Logon agent branch, to add the required authentication
#       for MS OFBA compliant applications.
#
    proc write_log {level message} {

        ACCESS::log $level "\[MSOFBA\] $message"
#       Logs printing for 12.x or older releases
#       log -noname accesscontrol.local1.$level "01490000: \[MSOFBA\] $message"
    }

    proc is_ofba_passthrough_uri {uri} {
        for { set i 0 } { $i < [llength $static::MS_OFBA_PASSTHROUGH_URI_LIST] } { incr i } {
            if { $uri == [lindex $static::MS_OFBA_PASSTHROUGH_URI_LIST $i] } {
                return 1;
            }
        }
        return 0
    }

    when RULE_INIT {
        set static::MS_OFBA_ENABLED_CLIENT_TYPE "ms-ofba-compliant"
        set static::MS_OFBA_AUTH_REQ_URI "/ms-ofba-req-auth"
        set static::MS_OFBA_AUTH_RETURN_URI "/ms-ofba-auth-success"
        set static::MS_OFBA_AUTH_DIALOG_SZ "800x600"
        set static::MS_OFBA_AUTH_SUCCESS_BODY "<html><head><title>User Authenticated</title></head><body><b>Successful OFBA authentication</b></body></html>"
        set static::MS_OFBA_IRULE_DG "sys_APM_MS_Office_OFBA_DG"
        set static::MULTI_DOMAIN_AUTH_RESP_URI "/f5networks-sso-resp"
        set static::MS_OFBA_PASSTHROUGH_URI_LIST {$static::MULTI_DOMAIN_AUTH_RESP_URI "/my.status.eps" "/my.report.eps"}
# sp_persistent_ck: would help to share the session from sharepoint site to
# office applications, if enabled.
        set static::SP_PERSISTENT_CK "MRHSOffice"
        set static::SP_PERSISTENT_CK_TIMEOUT 60
        set static::MS_OFBA_AUTH_TYPE_COOKIE "Auth-Type"
        set static::MS_OFBA_AUTH_TYPE_COOKIE_VALUE "ms-ofba"
    }

    when CLIENT_ACCEPTED {
        if { ![info exists ofba_user_agent_list] } {
# check for config change from datagroup
# since this iRule is read-only, dg config change is done in CLIENT_ACCEPTED rather than in RULE_INIT
            set ofba_user_agent_list [class search -value -all $static::MS_OFBA_IRULE_DG starts_with useragent]
            set f_sp_persistent_ck [class search -value $static::MS_OFBA_IRULE_DG equals ie_sp_session_sharing_enabled]
            set sp_persistent_ck_timeout [class search -value $static::MS_OFBA_IRULE_DG equals ie_sp_session_sharing_inactivity_timeout]
            set ofba_auth_dialog_sz [class search -value $static::MS_OFBA_IRULE_DG equals ofba_auth_dialog_size]
        }
    }

    when HTTP_REQUEST {
# client detection, for ofba client
        set ms_sp_client_type "none"
        set http_path [string tolower [HTTP::path]]
        set http_user_agent [string tolower [HTTP::header "User-Agent"]]
        set session_id [HTTP::cookie value "MRHSession"]
        set f_allow_session 0
        set ms_ofba_auth_cookie ""

        if {[HTTP::header exists "X-FORMS_BASED_AUTH_ACCEPTED"] &&
            (([HTTP::header "X-FORMS_BASED_AUTH_ACCEPTED"] equals "t") ||
             ([HTTP::header "X-FORMS_BASED_AUTH_ACCEPTED"] equals "f"))} {
                set ms_sp_client_type "ms-ofba"
            } elseif { $http_path == $static::MS_OFBA_AUTH_REQ_URI } {
                set ms_sp_client_type "ms-ofba"
            } else {
                if {(!($http_user_agent contains "frontpage") && [string match -nocase {*mozilla*} $http_user_agent]) ||
                    [string match -nocase {*opera*} $http_user_agent]} {
                        set ms_sp_client_type "browser"
                        set ms_ofba_auth_cookie [HTTP::cookie value $static::MS_OFBA_AUTH_TYPE_COOKIE]
                        if { $ms_ofba_auth_cookie == $static::MS_OFBA_AUTH_TYPE_COOKIE_VALUE } {
                            # ofba authentication is still in progress, there may be a case where initial
                            # access denied and user is retrying the session without closing the ofba
                            # initiated browser
                            set ms_sp_client_type "ms-ofba"
                            call write_log debug "Detecting the client type as ms-ofba based auth type cookie"
                        }
                    } else {
                        foreach ofba_user_agent $ofba_user_agent_list {
                            set ofba_user_agent [string trim $ofba_user_agent]
                            if { $ofba_user_agent != "" && [string match -nocase *$ofba_user_agent* $http_user_agent] } {
                                set ms_sp_client_type "ms-ofba"
                                    break
                            }
                        }
                    }
            }

        if { $ms_sp_client_type == "ms-ofba" } {
            call write_log debug "Client-type: (ms-ofba-compliant), http path: ($http_path), user agent: ($http_user_agent)"
        }

        if { $ms_sp_client_type != "ms-ofba" } {
            return
        } elseif { $session_id != "" } {
            if { [ACCESS::session exists -state_allow $session_id] } {
                set f_allow_session 1
                return
            }
        } elseif { $f_sp_persistent_ck == "1" && [HTTP::cookie exists $static::SP_PERSISTENT_CK] } {
            set sp_persistent_ck_value [HTTP::cookie value $static::SP_PERSISTENT_CK]
            if { $sp_persistent_ck_value != "" && [ACCESS::session exists -state_allow $sp_persistent_ck_value] } {
                if {not ([catch {HTTP::cookie insert name "MRHSession" value $sp_persistent_ck_value}]) } {
                    call write_log debug "Restored persistent cookie for sid: ($sp_persistent_ck_value)"
                    set f_allow_session 1
                    return
                } else {
                    call write_log error "Restoring persistent cookie failed for sid: ($sp_persistent_ck_value)"
                    unset sp_persistent_ck_value
                }
            } else {
                unset sp_persistent_ck_value
            }
        }

        if { !($f_allow_session) && $http_path != $static::MS_OFBA_AUTH_REQ_URI } {
            if { $ms_ofba_auth_cookie == $static::MS_OFBA_AUTH_TYPE_COOKIE_VALUE } {
                if { ![call is_ofba_passthrough_uri $http_path]  } {
                    call write_log debug "Redirecting for MS OFBA, based on auth type"
                    HTTP::respond 302 -version 1.1 -noserver Location $static::MS_OFBA_AUTH_REQ_URI
                }
            } else {
                call write_log debug "Responding 403 for MS OFBA initiation"
                if {$ofba_auth_dialog_sz == ""} {
                    set ofba_auth_dialog_sz $static::MS_OFBA_AUTH_DIALOG_SZ
                }
                HTTP::respond 403 -version "1.1" noserver \
                    "X-FORMS_BASED_AUTH_REQUIRED" "https://[HTTP::host]$static::MS_OFBA_AUTH_REQ_URI" \
                    "X-FORMS_BASED_AUTH_RETURN_URL" "https://[HTTP::host]$static::MS_OFBA_AUTH_RETURN_URI" \
                    "X-FORMS_BASED_AUTH_DIALOG_SIZE" $ofba_auth_dialog_sz \
                    "Set-Cookie" "MRHSession=deleted; expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;secure" \
                    "Set-Cookie" "LastMRH_Session=deleted; expires=Thu, 01 Jan 1970 00:00:00 GMT;path=/;secure" \
                    "Set-Cookie" "$static::MS_OFBA_AUTH_TYPE_COOKIE=$static::MS_OFBA_AUTH_TYPE_COOKIE_VALUE;path=/;secure;HttpOnly" \
                    "Connection" "Close"
            }
        }
    }

    when HTTP_RESPONSE {
        if { $f_sp_persistent_ck == "1" && ([info exists ms_sp_client_type] && $ms_sp_client_type == "browser") && $session_id != ""} {
            if {$sp_persistent_ck_timeout == ""} {
                set sp_persistent_ck_timeout $static::SP_PERSISTENT_CK_TIMEOUT
            }
            call write_log debug "Set-Cookie for SharePoint persistent cookie: ($static::SP_PERSISTENT_CK) for sid: ($session_id), having timeout: ($sp_persistent_ck_timeout)"

            HTTP::cookie remove $static::SP_PERSISTENT_CK
            HTTP::cookie insert name $static::SP_PERSISTENT_CK value $session_id path "/"
            HTTP::cookie expires $static::SP_PERSISTENT_CK $sp_persistent_ck_timeout relative
            HTTP::cookie secure $static::SP_PERSISTENT_CK enable
            HTTP::cookie httponly $static::SP_PERSISTENT_CK enable

        } elseif { [info exists sp_persistent_ck_value] && $sp_persistent_ck_value ne "" } {
            call write_log debug "Restoring Cookie for MRHSession from persistent cookie: ($sp_persistent_ck_value)"

            HTTP::cookie insert name MRHSession value $sp_persistent_ck_value path "/"
            HTTP::cookie secure MRHSession enable
            unset sp_persistent_ck_value
        }
    }

    when ACCESS_SESSION_STARTED {
        if { ![info exists ms_sp_client_type] || $ms_sp_client_type != "ms-ofba"} {
            return
        }
        ACCESS::session data set session.client.type $static::MS_OFBA_ENABLED_CLIENT_TYPE
    }

    when ACCESS_ACL_ALLOWED {
        switch -glob -- [string tolower [HTTP::path]] $static::MS_OFBA_AUTH_REQ_URI {
            ACCESS::respond 302 noserver Location "https://[HTTP::host]$static::MS_OFBA_AUTH_RETURN_URI"
        } $static::MS_OFBA_AUTH_RETURN_URI {
            ACCESS::respond 200 content $static::MS_OFBA_AUTH_SUCCESS_BODY noserver \
                "Set-Cookie" "$static::MS_OFBA_AUTH_TYPE_COOKIE=deleted;expires=Thu, 01 Jan 1970 00:00:00 GMT;;path=/;secure;HttpOnly"
        } "*/signout.aspx" {
            ACCESS::respond 302 noserver Location "/vdesk/hangup.php3"
                return
        } "/_layouts/accessdenied.aspx" {
            if {[string tolower [URI::query [HTTP::uri] loginasanotheruser]] equals "true" } {
                ACCESS::session remove
                ACCESS::respond 302 noserver Location "/"
                return
            }
        } default {
        }
    }
definition-signature e637kI9h5Ix7GFOay3azJpy0f7omhsLIP4EQQgdAxYzNVqFFpHpDlig4J/vuG/QbYUg5i0VDCnKNeL6FGQhMtIT6BNW9ucPGv46CKuS4UHxffnFGETafdGXnQg9j3RZGakjHZAwJmaQ0jLaXVG0tGo7e2P7lS6SC192xI8VqAkihMQCS7DaWDWuqYUeULk4YIPb8nGyw+3ZKCPTkOCqxWS4v2zMEhtCA7A9AzJAH2kg8o6HiEjEEt+PI6BclKOxyONdGkskEFBjqp1GZAlfRkcHbeFvgvXMa9ODZSzFHtT6rV+YsqmGfd4KHk5azrTCfhitvfU2miAD4M2/rHD1y/Q==

}

#a new data table begin:
sys file external-monitor arg_example {
    system-path "/config/monitors/arg_example"
}

#a new data table begin:
sys file external-monitor sample_monitor {
    system-path "/config/monitors/sample_monitor"
}

#a new data table begin:
sys file external-monitor paap_version_monitor {
    system-path "/config/monitors/paap_version_sample"
}

#a new data table begin:
sys file ssl-cert f5-irule.crt {
    system-path "/config/ssl/ssl.crt/f5-irule.crt"
}

#a new data table begin:
sys file ssl-cert /Common/f5-ca-bundle.crt {
    system-path "/config/ssl/ssl.crt/f5-ca-bundle.crt"
}

#a new data table begin:
sys file ssl-cert /Common/default.crt {
    system-path "/config/ssl/ssl.crt/default.crt"
}

#a new data table begin:
sys file ssl-cert /Common/ca-bundle.crt {
    system-path "/config/ssl/ssl.crt/ca-bundle.crt"
}

#a new data table begin:
sys file ssl-key default.key {
    system-path "/config/ssl/ssl.key/default.key"
}

# CA-bundle manager for system default ca-bundle.crt
#a new data table begin:
sys crypto ca-bundle-manager ca-bundle {
    include-url {
        https://cdn.f5.com/product/ca-bundle/blended-bundle.crt
    }
    trusted-ca-bundle /Common/f5-ca-bundle.crt
}

# URL DB Related settings
#a new data table begin:
sys url-db download-schedule urldb {
    start-time 01:00
    end-time 03:00
}

#a new data table begin:
sys crypto allow-key-export {
    value enabled
}

#-------------------------------------------------------------------------------
# APM (SAM)
#-------------------------------------------------------------------------------
apm profile access access {
    default-language "en"
    accept-languages {"en"}
}
apm resource remote-desktop citrix-client-bundle default-citrix-client-bundle {
}
apm client-packaging client-packaging {
}

apm profile connectivity connectivity {
    compression-codecs { deflate lzo bzip2 }
    compression enabled
    client-policy {
        connectivity_clientPolicy { }
    }
    citrix-client-bundle /Common/default-citrix-client-bundle
}
apm profile remote-desktop remotedesktop {}
apm profile exchange exchange {
    active-sync-auth-type basic
    active-sync-sso-config none
    active-sync-url "/microsoft-server-activesync*"
    auto-discover-auth-type basic
    auto-discover-sso-config none
    auto-discover-url "/autodiscover/*"
    ntlm-auth-name none
    offline-address-book-auth-type basic
    offline-address-book-sso-config none
    offline-address-book-url "/oab/*"
    rpc-over-http-auth-type basic
    rpc-over-http-sso-config none
    rpc-over-http-url "/rpc/rpcproxy.dll"
    user-agent-pattern-for-utf8 "Android*"
    web-service-auth-type basic
    web-service-sso-config none
    web-service-url "/ews/*"
}
apm profile eca eca {}
apm profile vdi vdi {}

apm apm-avr-config apm-avr-config {
    avr-collect-data true
    avr-sampling true
}

apm profile oauth oauth {
    db-instance /Common/oauthdb
}
apm profile oauthplugin oauthplugin {}

apm profile ping-access pingaccess {}

#-------------------------------------------------------------------------------
# WOM
#-------------------------------------------------------------------------------
#a new data table begin:
wom profile cifs cifs { }
#a new data table begin:
wom profile isession isession {
    compression-codecs { deflate lzo bzip2 }
    compression enabled
}
#a new data table begin:
wom profile isession isession-encrypt {
    data-encryption enabled
}
#a new data table begin:
wom profile isession isession-mapi {
    defaults-from /Common/isession
}
#a new data table begin:
wom profile isession isession-softwoc {
    defaults-from /Common/isession
    deduplication disabled
}
#a new data table begin:
wom profile mapi mapi {
    native-compression disabled
}
#a new data table begin:
wom profile passthru-woc-plugin passthruwocplugin { }

#-------------------------------------------------------------------------------
# IPsec
#-------------------------------------------------------------------------------
#a new data table begin:
net ipsec ike-peer anonymous {
    my-cert-file /Common/default.crt
    my-cert-key-file /Common/default.key
    my-id-type asn1dn
    peers-id-type asn1dn
    state disabled
    verify-cert false
}
#a new data table begin:
sys log-config publisher default-ipsec-log-publisher {
    destinations {
        /Common/local-syslog
    }
}


#-------------------------------------------------------------------------------
# PEM
#-------------------------------------------------------------------------------
pem profile spm spm { }
pem profile subscriber-mgmt subscriber-mgmt { }
pem profile diameter-endpoint diameter-endpoint {
    product-name "BIG-IP"
    gx-session-id-prefix "Gx.BIG-IP.f5net.com"
    gy-session-id-prefix "Gy.BIG-IP.f5net.com"
    sd-session-id-prefix "Sd.BIG-IP.f5net.com"
    msg-retransmit-delay 1500
    msg-max-retransmits 2
    fatal-grace-time {
	time 500
	enabled yes
    }
}
pem profile radius-aaa radiusaaa { }

#-------------------------------------------------------------------------------
# Classification Engine presets
#-------------------------------------------------------------------------------
#a new data table begin:
ltm classification ce ce {
    flow-bundling on
    allow-reclassification on
    cache-results on
}
#a new data table begin:
ltm classification ce ce_pem {
    flow-bundling on
    allow-reclassification on
    cache-results on
}
#a new data table begin:
ltm classification ce ce_apm_swg {
    flow-bundling on
    allow-reclassification on
    cache-results off
}

#a new data table begin:
ltm classification ce ce_afm {
    flow-bundling on
    allow-reclassification off
    cache-results off
}

#-------------------------------------------------------------------------------
# Management Port Firewall
#-------------------------------------------------------------------------------
#a new data table begin:
sys log-config publisher default-mgmt-acl-log-publisher { }

#-------------------------------------------------------------------------------
# API Protection
#-------------------------------------------------------------------------------
api-protection profile apiprotection apiprotection {}

